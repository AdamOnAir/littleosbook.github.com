<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Erik Helin, Adam Renberg" />
  <title>The little book about OS development</title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="book.css" type="text/css" />
</head>
<body>
<div id='wrapper'>
<div id="header">
<h1 class="title">The little book about OS development</h1>
<h2 class="author">Erik Helin, Adam Renberg</h2>
</div>
<div class="subheader">
Commit: b921493843afa6acdf63cbf438a44e003b36db61
<a class="pdflink" href="book.pdf" title="PDF version">PDF version</a>
</div>
<div id='content'>
<div id="TOC">
<h1>Contents</h1>
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="#what-is-this-book-about"><span class="toc-section-number">1.1</span> What Is This Book About?</a></li>
<li><a href="#the-reader"><span class="toc-section-number">1.2</span> The Reader</a></li>
<li><a href="#credits-thanks-and-acknowledgements"><span class="toc-section-number">1.3</span> Credits, Thanks and Acknowledgements</a></li>
<li><a href="#changes-and-corrections"><span class="toc-section-number">1.4</span> Changes and Corrections</a></li>
<li><a href="#license"><span class="toc-section-number">1.5</span> License</a></li>
</ul></li>
<li><a href="#first-steps"><span class="toc-section-number">2</span> First Steps</a><ul>
<li><a href="#requirements"><span class="toc-section-number">2.1</span> Requirements</a></li>
<li><a href="#tools"><span class="toc-section-number">2.2</span> Tools</a><ul>
<li><a href="#the-easy-way"><span class="toc-section-number">2.2.1</span> The Easy Way</a></li>
<li><a href="#programming-languages"><span class="toc-section-number">2.2.2</span> Programming Languages</a></li>
<li><a href="#host-operating-system"><span class="toc-section-number">2.2.3</span> Host Operating System</a></li>
<li><a href="#build-system"><span class="toc-section-number">2.2.4</span> Build System</a></li>
<li><a href="#virtual-machine"><span class="toc-section-number">2.2.5</span> Virtual Machine</a></li>
</ul></li>
<li><a href="#booting"><span class="toc-section-number">2.3</span> Booting</a><ul>
<li><a href="#bios"><span class="toc-section-number">2.3.1</span> BIOS</a></li>
<li><a href="#the-bootloader"><span class="toc-section-number">2.3.2</span> The Bootloader</a></li>
<li><a href="#the-operating-system"><span class="toc-section-number">2.3.3</span> The Operating System</a></li>
</ul></li>
<li><a href="#hello-cafebabe"><span class="toc-section-number">2.4</span> Hello Cafebabe</a><ul>
<li><a href="#compiling-the-kernel"><span class="toc-section-number">2.4.1</span> Compiling the Kernel</a></li>
<li><a href="#linking-the-kernel"><span class="toc-section-number">2.4.2</span> Linking the Kernel</a></li>
<li><a href="#obtaining-grub"><span class="toc-section-number">2.4.3</span> Obtaining GRUB</a></li>
<li><a href="#building-an-iso-image"><span class="toc-section-number">2.4.4</span> Building an ISO Image</a></li>
<li><a href="#running-bochs"><span class="toc-section-number">2.4.5</span> Running Bochs</a></li>
</ul></li>
<li><a href="#further-reading"><span class="toc-section-number">2.5</span> Further Reading</a></li>
</ul></li>
<li><a href="#getting-to-c"><span class="toc-section-number">3</span> Getting to C</a><ul>
<li><a href="#setting-up-a-stack"><span class="toc-section-number">3.1</span> Setting Up a Stack</a></li>
<li><a href="#calling-c-code-from-assembly"><span class="toc-section-number">3.2</span> Calling C Code From Assembly</a><ul>
<li><a href="#packing-structs"><span class="toc-section-number">3.2.1</span> Packing Structs</a></li>
</ul></li>
<li><a href="#compiling-c-code"><span class="toc-section-number">3.3</span> Compiling C Code</a></li>
<li><a href="#build-tools"><span class="toc-section-number">3.4</span> Build Tools</a></li>
<li><a href="#further-reading-1"><span class="toc-section-number">3.5</span> Further Reading</a></li>
</ul></li>
<li><a href="#output"><span class="toc-section-number">4</span> Output</a><ul>
<li><a href="#talking-to-the-hardware"><span class="toc-section-number">4.1</span> Talking to the Hardware</a></li>
<li><a href="#the-framebuffer"><span class="toc-section-number">4.2</span> The Framebuffer</a><ul>
<li><a href="#writing-text"><span class="toc-section-number">4.2.1</span> Writing Text</a></li>
<li><a href="#moving-the-cursor"><span class="toc-section-number">4.2.2</span> Moving the Cursor</a></li>
<li><a href="#the-driver"><span class="toc-section-number">4.2.3</span> The Driver</a></li>
</ul></li>
<li><a href="#the-serial-ports"><span class="toc-section-number">4.3</span> The Serial Ports</a><ul>
<li><a href="#configuring-the-serial-port"><span class="toc-section-number">4.3.1</span> Configuring the Serial Port</a></li>
<li><a href="#configuring-the-line"><span class="toc-section-number">4.3.2</span> Configuring the Line</a></li>
<li><a href="#configuring-the-fifo-queues"><span class="toc-section-number">4.3.3</span> Configuring the FIFO Queues</a></li>
<li><a href="#configuring-the-modem"><span class="toc-section-number">4.3.4</span> Configuring the modem</a></li>
<li><a href="#writing-to-the-serial-port"><span class="toc-section-number">4.3.5</span> Writing to the Serial Port</a></li>
<li><a href="#configuring-bochs"><span class="toc-section-number">4.3.6</span> Configuring Bochs</a></li>
<li><a href="#the-driver-1"><span class="toc-section-number">4.3.7</span> The Driver</a></li>
</ul></li>
<li><a href="#further-reading-2"><span class="toc-section-number">4.4</span> Further Reading</a></li>
</ul></li>
<li><a href="#segmentation"><span class="toc-section-number">5</span> Segmentation</a><ul>
<li><a href="#accessing-memory"><span class="toc-section-number">5.1</span> Accessing Memory</a></li>
<li><a href="#the-global-descriptor-table-gdt"><span class="toc-section-number">5.2</span> The Global Descriptor Table (GDT)</a></li>
<li><a href="#creating-and-loading-the-gdt"><span class="toc-section-number">5.3</span> Creating and Loading the GDT</a></li>
<li><a href="#further-reading-3"><span class="toc-section-number">5.4</span> Further Reading</a></li>
</ul></li>
<li><a href="#interrupts-and-input"><span class="toc-section-number">6</span> Interrupts and Input</a><ul>
<li><a href="#interrupts-handlers"><span class="toc-section-number">6.1</span> Interrupts Handlers</a></li>
<li><a href="#creating-an-entry-in-the-idt"><span class="toc-section-number">6.2</span> Creating an Entry in the IDT</a></li>
<li><a href="#creating-a-generic-interrupt-handler"><span class="toc-section-number">6.3</span> Creating a Generic Interrupt Handler</a></li>
<li><a href="#loading-the-idt"><span class="toc-section-number">6.4</span> Loading the IDT</a></li>
<li><a href="#programmable-interrupt-controller-pic"><span class="toc-section-number">6.5</span> Programmable Interrupt Controller (PIC)</a></li>
<li><a href="#reading-input-from-the-keyboard"><span class="toc-section-number">6.6</span> Reading Input from the Keyboard</a></li>
<li><a href="#further-reading-4"><span class="toc-section-number">6.7</span> Further Reading</a></li>
</ul></li>
<li><a href="#the-road-to-user-mode"><span class="toc-section-number">7</span> The Road to User Mode</a><ul>
<li><a href="#loading-a-program"><span class="toc-section-number">7.1</span> Loading a Program</a><ul>
<li><a href="#grub-modules"><span class="toc-section-number">7.1.1</span> GRUB Modules</a></li>
</ul></li>
<li><a href="#executing-a-program"><span class="toc-section-number">7.2</span> Executing a Program</a><ul>
<li><a href="#a-very-simple-program"><span class="toc-section-number">7.2.1</span> A Very Simple Program</a></li>
<li><a href="#compiling"><span class="toc-section-number">7.2.2</span> Compiling</a></li>
<li><a href="#finding-the-program-in-memory"><span class="toc-section-number">7.2.3</span> Finding the Program in Memory</a></li>
<li><a href="#jumping-to-the-code"><span class="toc-section-number">7.2.4</span> Jumping to the Code</a></li>
</ul></li>
<li><a href="#the-beginning-of-user-mode"><span class="toc-section-number">7.3</span> The Beginning of User Mode</a></li>
</ul></li>
<li><a href="#virtual-memory-an-introduction"><span class="toc-section-number">8</span> Virtual Memory, an Introduction</a><ul>
<li><a href="#virtual-memory-through-segmentation"><span class="toc-section-number">8.1</span> Virtual Memory Through Segmentation?</a></li>
<li><a href="#further-reading-5"><span class="toc-section-number">8.2</span> Further Reading</a></li>
</ul></li>
<li><a href="#paging"><span class="toc-section-number">9</span> Paging</a><ul>
<li><a href="#why-paging"><span class="toc-section-number">9.1</span> Why Paging?</a></li>
<li><a href="#paging-in-x86"><span class="toc-section-number">9.2</span> Paging in x86</a><ul>
<li><a href="#identity-paging"><span class="toc-section-number">9.2.1</span> Identity Paging</a></li>
<li><a href="#enabling-paging"><span class="toc-section-number">9.2.2</span> Enabling Paging</a></li>
<li><a href="#a-few-details"><span class="toc-section-number">9.2.3</span> A Few Details</a></li>
</ul></li>
<li><a href="#higher-half-kernel"><span class="toc-section-number">9.3</span> Higher-half Kernel</a><ul>
<li><a href="#reasons-to-not-identity-map-the-kernel"><span class="toc-section-number">9.3.1</span> Reasons to Not Identity Map the Kernel</a></li>
<li><a href="#the-virtual-address-for-the-kernel"><span class="toc-section-number">9.3.2</span> The Virtual Address for the Kernel</a></li>
<li><a href="#placing-the-kernel-at-0xc010000"><span class="toc-section-number">9.3.3</span> Placing the Kernel at <code>0xC010000</code></a></li>
<li><a href="#higher-half-linker-script"><span class="toc-section-number">9.3.4</span> Higher-half Linker Script</a></li>
<li><a href="#entering-the-higher-half"><span class="toc-section-number">9.3.5</span> Entering the Higher Half</a></li>
<li><a href="#running-in-the-higher-half"><span class="toc-section-number">9.3.6</span> Running in the Higher Half</a></li>
</ul></li>
<li><a href="#virtual-memory-through-paging"><span class="toc-section-number">9.4</span> Virtual Memory Through Paging</a></li>
<li><a href="#further-reading-6"><span class="toc-section-number">9.5</span> Further Reading</a></li>
</ul></li>
<li><a href="#page-frame-allocation"><span class="toc-section-number">10</span> Page Frame Allocation</a><ul>
<li><a href="#managing-available-memory"><span class="toc-section-number">10.1</span> Managing Available Memory</a><ul>
<li><a href="#how-much-memory-is-there"><span class="toc-section-number">10.1.1</span> How Much Memory is There?</a></li>
<li><a href="#managing-available-memory-1"><span class="toc-section-number">10.1.2</span> Managing Available Memory</a></li>
</ul></li>
<li><a href="#how-can-we-access-a-page-frame"><span class="toc-section-number">10.2</span> How Can We Access a Page Frame?</a></li>
<li><a href="#a-kernel-heap"><span class="toc-section-number">10.3</span> A Kernel Heap</a></li>
<li><a href="#further-reading-7"><span class="toc-section-number">10.4</span> Further reading</a></li>
</ul></li>
<li><a href="#user-mode"><span class="toc-section-number">11</span> User Mode</a><ul>
<li><a href="#segments-for-user-mode"><span class="toc-section-number">11.1</span> Segments for User Mode</a></li>
<li><a href="#setting-up-for-user-mode"><span class="toc-section-number">11.2</span> Setting Up For User Mode</a></li>
<li><a href="#entering-user-mode"><span class="toc-section-number">11.3</span> Entering User Mode</a></li>
<li><a href="#using-c-for-user-mode-programs"><span class="toc-section-number">11.4</span> Using C for User Mode Programs</a><ul>
<li><a href="#a-c-library"><span class="toc-section-number">11.4.1</span> A C Library</a></li>
</ul></li>
<li><a href="#further-reading-8"><span class="toc-section-number">11.5</span> Further Reading</a></li>
</ul></li>
<li><a href="#file-systems"><span class="toc-section-number">12</span> File Systems</a><ul>
<li><a href="#why-a-file-system"><span class="toc-section-number">12.1</span> Why a File System?</a></li>
<li><a href="#a-simple-file-system"><span class="toc-section-number">12.2</span> A Simple File System</a></li>
<li><a href="#inodes-and-writable-file-systems"><span class="toc-section-number">12.3</span> Inodes and Writable File Systems</a></li>
<li><a href="#a-virtual-file-system-and-devfs"><span class="toc-section-number">12.4</span> A Virtual File System and devfs</a></li>
<li><a href="#further-reading-9"><span class="toc-section-number">12.5</span> Further Reading</a></li>
</ul></li>
<li><a href="#system-calls"><span class="toc-section-number">13</span> System Calls</a><ul>
<li><a href="#what-is-a-system-call"><span class="toc-section-number">13.1</span> What is a System Call?</a></li>
<li><a href="#designing-system-calls"><span class="toc-section-number">13.2</span> Designing System Calls</a></li>
<li><a href="#implementing-system-calls"><span class="toc-section-number">13.3</span> Implementing System Calls</a></li>
<li><a href="#further-reading-10"><span class="toc-section-number">13.4</span> Further Reading</a></li>
</ul></li>
<li><a href="#scheduling"><span class="toc-section-number">14</span> Scheduling</a><ul>
<li><a href="#creating-new-processes"><span class="toc-section-number">14.1</span> Creating New Processes</a></li>
<li><a href="#cooperative-scheduling-with-yielding"><span class="toc-section-number">14.2</span> Cooperative Scheduling with Yielding</a></li>
<li><a href="#preemptive-scheduling-with-the-timer"><span class="toc-section-number">14.3</span> Preemptive Scheduling with the Timer</a><ul>
<li><a href="#programmable-interval-timer"><span class="toc-section-number">14.3.1</span> Programmable Interval Timer</a></li>
<li><a href="#separate-kernel-stacks-for-processes"><span class="toc-section-number">14.3.2</span> Separate Kernel Stacks for Processes</a></li>
<li><a href="#difficulties-with-preemptive-scheduling"><span class="toc-section-number">14.3.3</span> Difficulties with Preemptive Scheduling</a></li>
</ul></li>
<li><a href="#further-reading-11"><span class="toc-section-number">14.4</span> Further Reading</a></li>
</ul></li>
<li><a href="#references"><span class="toc-section-number">15</span> References</a></li>
</ul>
</div>
<h1 id="introduction"><a href="#TOC"><span class="header-section-number">1</span> Introduction</a></h1>
<h2 id="what-is-this-book-about"><a href="#TOC"><span class="header-section-number">1.1</span> What Is This Book About?</a></h2>
<p>This book is not about the theory behind operating systems, or how any specific operating system (OS) works. For the first we recommend Modern Operating Systems by Andrew Tanenbaum <span class="citation">[1]</span>. For the second the internet is your friend.</p>
<p>This book is a practical guide to writing your own x86 operating system. It is designed to not give too much away with samples and code excerpts, but still give enough help with the technical details. We’ve tried to collect parts of the vast (and often excellent) expanse of material and tutorials out there, on the web and otherwise, and add our own insights into the problems we encountered and struggled with.</p>
<p>The starting chapters are naturally quite detailed and explicit, to quickly get you into coding. Later chapters give more of an outline of what is needed, as more and more of the implementation and design becomes up to the reader, who should now be more familiar with the world of kernel development. At the end of some chapters there are links for further reading, which might be interesting and give a deeper understanding of the topics covered.</p>
<h2 id="the-reader"><a href="#TOC"><span class="header-section-number">1.2</span> The Reader</a></h2>
<p>The reader of this book should be comfortable with UNIX/Linux, systems programming and the C language in general. This book is of course also a great way to get started learning those things, but it will be tougher going, especially where we implicitly make use of them. Search engines and other tutorials are often helpful.</p>
<h2 id="credits-thanks-and-acknowledgements"><a href="#TOC"><span class="header-section-number">1.3</span> Credits, Thanks and Acknowledgements</a></h2>
<p>We’d like to thank the OSDev community <span class="citation">[2]</span> for their great wiki and helpful members, and James Malloy for his eminent kernel development tutorial <span class="citation">[3]</span>. We’d also like to thank our supervisor Torbjörn Granlund for his insightful questions and our interesting discussions.</p>
<p>Most of the CSS formatting of the book is based on the work by Scott Chacon for the book Pro Git, <a href="http://progit.org/"><code class="url">http://progit.org/</code></a>.</p>
<h2 id="changes-and-corrections"><a href="#TOC"><span class="header-section-number">1.4</span> Changes and Corrections</a></h2>
<p>This book is hosted on Github - if you have any suggestions, comments or corrections, just fork the book, write your changes, and send us a pull request. We’ll happily incorporate anything that makes this book better.</p>
<h2 id="license"><a href="#TOC"><span class="header-section-number">1.5</span> License</a></h2>
<p>All content is under the <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/us/">Creative Commons Attribution Non Commercial Share Alike 3.0 license</a>.</p>
<h1 id="first-steps"><a href="#TOC"><span class="header-section-number">2</span> First Steps</a></h1>
<p>Developing an operating system (OS) is no easy task, and the question &quot; Where do I start?&quot; is likely to come up several times during the course of the project. This chapter will help you set up your development environment and booting a very small (and boring) operating system.</p>
<h2 id="requirements"><a href="#TOC"><span class="header-section-number">2.1</span> Requirements</a></h2>
<p>In this book, we will assume that you are familiar with the C programming language and that you have some programming experience. It will be also be helpful if you have basic understanding of assembly code.</p>
<h2 id="tools"><a href="#TOC"><span class="header-section-number">2.2</span> Tools</a></h2>
<h3 id="the-easy-way"><a href="#TOC"><span class="header-section-number">2.2.1</span> The Easy Way</a></h3>
<p>The easiest way to get all the required tools is to use Ubuntu <span class="citation">[4]</span> as your operating system. If you don’t want to run Ubuntu natively on your computer, it works just as well running it in a virtual machine, for example in VirtualBox <span class="citation">[5]</span>.</p>
<p>The packages needed can then be installed by running</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">sudo</span> apt-get <span class="kw">install</span> build-essential <span class="kw">nasm</span> genisoimage bochs bochs-x</code></pre>
<h3 id="programming-languages"><a href="#TOC"><span class="header-section-number">2.2.2</span> Programming Languages</a></h3>
<p>The operating system will be developed using the C programming language <span class="citation">[6]</span><span class="citation">[7]</span>. The reason for using C is because developing an OS requires a very precise control of the generated code and direct access to memory, something which C enables. Other languages that provides the same features can also be used, but this book will only cover C.</p>
<p>The code will make use of one type attribute that is specific for GCC <span class="citation">[8]</span></p>
<pre><code>__attribute__((packed))__</code></pre>
<p>(the meaning of the attribute will be explained later). Therefore, the example code might be hard to compile using another C compiler.</p>
<p>For writing assembly, we choose NASM <span class="citation">[9]</span> as the assembler. The reason for this is that we prefer NASM’s syntax over GNU Assembler.</p>
<p>Shell <span class="citation">[10]</span> will be used as the scripting language throughout the book.</p>
<h3 id="host-operating-system"><a href="#TOC"><span class="header-section-number">2.2.3</span> Host Operating System</a></h3>
<p>All the examples assumes that the code is being compiled on a UNIX like operating system. All the code is known to compile on Ubuntu <span class="citation">[4]</span> versions 11.04 and 11.10.</p>
<h3 id="build-system"><a href="#TOC"><span class="header-section-number">2.2.4</span> Build System</a></h3>
<p>GNU Make <span class="citation">[11]</span> has been used when constructing the example Makefiles, but we don’t make use of any GNU Make specific instructions.</p>
<h3 id="virtual-machine"><a href="#TOC"><span class="header-section-number">2.2.5</span> Virtual Machine</a></h3>
<p>When developing an OS, it’s very convenient to be able to run your code in a virtual machine instead of a physical one. Bochs <span class="citation">[12]</span> is an emulator for the x86 (IA-32) platform which is well suited for OS development due to its debugging features. Other popular choices are QEMU <span class="citation">[13]</span> and VirtualBox <span class="citation">[5]</span>, but we will use Bochs in this book.</p>
<h2 id="booting"><a href="#TOC"><span class="header-section-number">2.3</span> Booting</a></h2>
<p>The first goal when starting to develop an operating system is to be able to boot it. Booting an operating system consists of transferring control along a chain of small programs, each one more “powerful” than the previous one, where the operating system is the last “program”. See the following figure for an overview of the boot process.</p>
<div class="figure">
<img src="images/boot_chain.png" alt="An overview of the boot process, each box is a program." /><p class="caption">An overview of the boot process, each box is a program.</p>
</div>
<h3 id="bios"><a href="#TOC"><span class="header-section-number">2.3.1</span> BIOS</a></h3>
<p>When the PC is turned on, the computer will start a small program that adheres to the Basic Input Output System (BIOS) <span class="citation">[14]</span> standard. The program is usually stored on a read only memory chip on the motherboard of the PC. The original role of the BIOS program was export some library functions for printing to the screen, reading keyboard input etc. However, todays operating system does not use the BIOS functions, instead they use drivers that interacts directly with the hardware, bypassing the BIOS <span class="citation">[14]</span>.</p>
<p>BIOS is a legacy technology, it operates in 16-bit mode (all x86 CPUs are backwards compatible with 16-bit mode). Today, BIOS mainly runs some early diagnostics (power-on-self-test) and then transfers control to the bootloader.</p>
<h3 id="the-bootloader"><a href="#TOC"><span class="header-section-number">2.3.2</span> The Bootloader</a></h3>
<p>The BIOS program will transfer control of the PC to a program called <em>bootloader</em>. The bootloaders task is to transfer control to us, the operating system developers, and our code. However, due to some restrictions, the bootloader is often split into two parts, so the first part of the bootloader will transfer control to the second part which will finally give the control of the PC to the operating system.</p>
<p>Writing a bootloader involves writing a lot of low-level code that interacts with the BIOS, so in this book, we will use an existing bootloader, the GNU GRand Unified Bootloader (GRUB) <span class="citation">[15]</span>.</p>
<p>Using GRUB, the operating system can be built as an ordinary ELF <span class="citation">[16]</span> file, which will be loaded by GRUB into the correct memory location. However, the compilation requires some care regarding how things are to by laid out in memory, which will be discussed later in this chapter.</p>
<h3 id="the-operating-system"><a href="#TOC"><span class="header-section-number">2.3.3</span> The Operating System</a></h3>
<p>GRUB will transfer control to the operating system by jumping to the kernels start position in memory. Before the jump, GRUB will also look for a magic number to make sure that is is actually jumping to a kernel and not some random code. The magic number is part of the multiboot specification <span class="citation">[17]</span> which GRUB adheres to.</p>
<h2 id="hello-cafebabe"><a href="#TOC"><span class="header-section-number">2.4</span> Hello Cafebabe</a></h2>
<p>This section will show the implementation of the smallest possible operating system kernel that can be used together with GRUB. The only the kernel will do is write <code>0xCAFEBABE</code> to the <code>eax</code> register.</p>
<h3 id="compiling-the-kernel"><a href="#TOC"><span class="header-section-number">2.4.1</span> Compiling the Kernel</a></h3>
<p>This part of the kernel has to be written in assembly, since C requires a stack, which isn’t available at this point, since GRUB doesn’t set one up. The code for the kernel is:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">global</span> loader                   <span class="co">; the entry symbol for ELF</span>

MAGIC_NUMBER <span class="dt">equ</span> <span class="bn">0x1BADB002</span>     <span class="co">; define the magic number constant</span>
CHECKSUM     <span class="dt">equ</span> -MAGIC_NUMBER  <span class="co">; calculate the checksum (magic number + checksum should equal 0)</span>

<span class="kw">section</span> .text:                  <span class="co">; start of the text (code) section</span>
<span class="kw">align</span> <span class="dv">4</span>                         <span class="co">; the code must be 4 byte aligned</span>
    <span class="dt">dd</span> MAGIC_NUMBER             <span class="co">; write the magic number</span>
    <span class="dt">dd</span> CHECKSUM                 <span class="co">; write the checksum</span>

<span class="fu">loader:</span>                         <span class="co">; the loader label (defined as entry point in linker script)</span>
    <span class="kw">mov</span> <span class="kw">eax</span>, <span class="bn">0xCAFEBABE</span>         <span class="co">; place the number 0xCAFEBABE in the register eax</span>
<span class="fu">.loop:</span>
    <span class="kw">jmp</span> .<span class="kw">loop</span>                   <span class="co">; loop forever</span></code></pre>
<p>The only thing this kernel will do is write the very specific number <code>0xCAFEBABE</code> into the <code>eax</code> register. It is <em>very</em> unlikely that the number <code>0xCAFEBABE</code> would be in the <code>eax</code> register if our kernel did <em>not</em> put it there. Save the code in a file named <code>loader.s</code>.</p>
<p>The assembly code can now be compiled with the commando</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">nasm</span> -f elf32 loader.s</code></pre>
<p>to produce an 32 bits ELF <span class="citation">[16]</span> object file.</p>
<h3 id="linking-the-kernel"><a href="#TOC"><span class="header-section-number">2.4.2</span> Linking the Kernel</a></h3>
<p>The code must now be linked to produce an executable file, which requires some extra thought compared to when linking most programs. The reason for this is that we want GRUB to load the kernel at a memory address larger than or equal to <code>0x00100000</code> (1 megabyte (MB)). This is because addresses lower than 1 MB might be used by GRUB itself, by BIOS and for memory-mapped I/O. Therefore, the following linker script is needed:</p>
<pre><code>ENTRY(loader)           /* the name of the entry label */

. = 0x00100000          /* the code should be loaded at 1 MB */

.text ALIGN (0x1000)    /* align at 4 KB */
{
    *(.text)            /* all text sections from all files */
}

.rodata ALIGN (0x1000)  /* align at 4 KB */
{
    *(.rodata*)         /* all read-only data sections from all files */
}

.data ALIGN (0x1000)    /* align at 4 KB */
{
    *(.data)            /* all data sections from all files */
}

.bss ALIGN (0x1000)     /* align at 4 KB */
{
    *(COMMON)           /* all COMMON sections from all files */
    *(.bss)             /* all bss sections from all files */
}</code></pre>
<p>Save the linker script into a file called <code>link.ld</code>. The executable can now be linked by running</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ld</span> -T link.ld -melf_i386 loader.o -o kernel.elf</code></pre>
<p>where the file <code>kernel.elf</code> is the final executable.</p>
<h3 id="obtaining-grub"><a href="#TOC"><span class="header-section-number">2.4.3</span> Obtaining GRUB</a></h3>
<p>The GRUB version we will use is GRUB Legacy, since then the ISO image can be generated on systems using both GRUB Legacy and GRUB 2. We need the GRUB Legacy <code>stage2_eltorito</code> bootloader. This file be built from GRUB 0.97 by downloading the source from <a href="ftp://alpha.gnu.org/gnu/grub/grub-0.97.tar.gz"><code class="url">ftp://alpha.gnu.org/gnu/grub/grub-0.97.tar.gz</code></a>. However, the source code <code>configure</code> script doesn’t work well with Ubuntu <span class="citation">[18]</span>, so the binary files can be downloaded from <a href="files/stage2_eltorito">here</a>. Locate the file <code>stage2_eltorito</code> and copy it to your current folder.</p>
<h3 id="building-an-iso-image"><a href="#TOC"><span class="header-section-number">2.4.4</span> Building an ISO Image</a></h3>
<p>Now the code must be placed on a media that can be loaded by a virtual (or physical machine). In this book, we will use ISO <span class="citation">[19]</span> image files as the media, but one can also use floppy images, depending on what the virtual or physical machine supports.</p>
<p>The ISO image will be created with the program <code>genisoimage</code>. A folder must first be created that contains the files that will be on the ISO image. The following commands create the folder and copy the files to their correct places:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">mkdir</span> -p iso/boot/grub              <span class="co"># create folder structure</span>
<span class="kw">cp</span> stage2_eltorito iso/boot/grub/   <span class="co"># copy the bootloader</span>
<span class="kw">cp</span> kernel.ef iso/boot/              <span class="co"># copy the kernel</span></code></pre>
<p>Now a configuration file <code>menu.lst</code> for GRUB must be created. This file tells GRUB where the kernel is located and configures some options:</p>
<pre><code>default=0
timeout=0

title minios
kernel /boot/kernel.elf</code></pre>
<p>and be placed in the <code>iso/boot/grub/</code> folder. The <code>iso</code> folder should now look like:</p>
<pre><code>iso
|-- boot
  |-- grub
  | |-- menu.lst
  | |-- stage2_eltorito
  |-- kernel.elf</code></pre>
<p>The ISO image can now be generated with the command</p>
<pre><code>genisoimage -R                              \
            -b boot/grub/stage2_eltorito    \
            -no-emul-boot                   \
            -boot-load-size 4               \
            -A os                           \
            -input-charset utf8             \
            -quiet                          \
            -boot-info-table                \
            -o os.iso                       \
            iso</code></pre>
<p>where the flags are</p>
<table>
<col width="20%" />
<col width="79%" />
<thead>
<tr class="header">
<th align="right">Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">R</td>
<td align="left">Use the Rock Ridge protocol (needed by GRUB)</td>
</tr>
<tr class="even">
<td align="right">b</td>
<td align="left">The file to boot from (relative to the root folder of the ISO)</td>
</tr>
<tr class="odd">
<td align="right">no-emul-boot</td>
<td align="left">Do not perform any disk emulation</td>
</tr>
<tr class="even">
<td align="right">boot-load-size</td>
<td align="left">The number 512 byte sectors to load. Apparently most BIOS likes the number 4.</td>
</tr>
<tr class="odd">
<td align="right">boot-info-table</td>
<td align="left">Writes information about the ISO layout to ISO (needed by GRUB)</td>
</tr>
<tr class="even">
<td align="right">o</td>
<td align="left">The name of the iso</td>
</tr>
<tr class="odd">
<td align="right">A</td>
<td align="left">The label of the iso</td>
</tr>
<tr class="even">
<td align="right">input-charset</td>
<td align="left">The charset for the input files</td>
</tr>
<tr class="odd">
<td align="right">quiet</td>
<td align="left">Disable any output from genisoimage</td>
</tr>
</tbody>
</table>
<p>The final ISO image <code>os.iso</code> is now available.</p>
<h3 id="running-bochs"><a href="#TOC"><span class="header-section-number">2.4.5</span> Running Bochs</a></h3>
<p>Now that we have an ISO image with the operating system and GRUB, the final step is to run it in Bochs. Bochs needs a configuration file to start, and a simple configuration file is given below</p>
<pre><code>megs:            32
display_library: x
romimage:        file=/usr/share/bochs/BIOS-bochs-latest
vgaromimage:     file=/usr/share/bochs/VGABIOS-lgpl-latest
ata0-master:     type=cdrom, path=minios.iso, status=inserted
boot:            cdrom
log:             bochslog.txt
mouse:           enabled=1
clock:           sync=realtime, time0=local
cpu:             count=1, ips=1000000</code></pre>
<p>you might need to change the path to <code>romimage</code> and <code>vgaromimage</code> depending on how you installed Bochs. Save the file as <code>bochsrc.txt</code>. More information about the Bochs config file can be found at <span class="citation">[20]</span>.</p>
<p>You can now start the operating system by running</p>
<pre><code>bochs -f bochsrc.txt -q</code></pre>
<p><code>-f</code> tells Bochs to use the given configuration file and <code>-q</code> tells Bochs to skip the interactive start menu. You should now see Bochs starting and displaying a console with some information from GRUB on it.</p>
<p>After quitting Bochs, display the file log from Bochs by running</p>
<pre><code>cat bochslog.txt</code></pre>
<p>You should now see the state of the registers of Bochs somewhere in the output. If you find <code>RAX=00000000CAFEBABE</code> or <code>EAX=CAFEBABE</code> (depending on if you are running Bochs with or without 64 bit support), then your operating system has booted successfully!</p>
<h2 id="further-reading"><a href="#TOC"><span class="header-section-number">2.5</span> Further Reading</a></h2>
<ul>
<li>Gustavo Duertes has written an in-depth article about what actually happens when a computers boots up, <a href="http://duartes.org/gustavo/blog/post/how-computers-boot-up"><code class="url">http://duartes.org/gustavo/blog/post/how-computers-boot-up</code></a></li>
<li>Gustavo then continues to describe what the kernel does in the very early stages at <a href="http://duartes.org/gustavo/blog/post/kernel-boot-process"><code class="url">http://duartes.org/gustavo/blog/post/kernel-boot-process</code></a></li>
<li>The OSDev wiki also contains a nice article about booting a computer, <a href="http://wiki.osdev.org/Boot_Sequence"><code class="url">http://wiki.osdev.org/Boot_Sequence</code></a></li>
</ul>
<h1 id="getting-to-c"><a href="#TOC"><span class="header-section-number">3</span> Getting to C</a></h1>
<p>Now that you’ve managed to boot your operating system, it’s time to think about the language we’re currently using, assembly. Assembly is very good for interacting with the CPU and enables maximum control over every aspect of the code. However, at least for the authors, C is a much more convenient language to use. Therefore, we would like to use C as much as possible and only assembler where it make sense.</p>
<h2 id="setting-up-a-stack"><a href="#TOC"><span class="header-section-number">3.1</span> Setting Up a Stack</a></h2>
<p>Before we can program in C, we need a stack. This is because we can <em>not</em> guarantee that a C program does <em>not</em> make use of a stack. Setting up a stack is not harder than to make the <code>esp</code> register point to the end of an area of free memory that is correctly aligned (remember that the stack grows towards lower addresses).</p>
<p>We could make <code>esp</code> just point to some area in memory, since so far, the only thing in the memory is GRUB, BIOS, the OS kernel and some memory-mapped I/O. This is not a good idea, since we don’t know which address to point to, since we don’t know how much memory is available, and if any memory is reserved by BIOS. A better idea is to reserve a piece of memory in the <code>bss</code> section in the ELF binary of the kernel. That way, when GRUB loads the ELF binary, GRUB will allocate memory for us.</p>
<p>To declare uninitialized data, the NASM pseudo-instruction <code>resb</code> <span class="citation">[21]</span> can be used</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">KERNEL_STACK_SIZE <span class="dt">equ</span> <span class="dv">4096</span>                  <span class="co">; size of stack in bytes</span>

<span class="kw">section</span> .bss
<span class="kw">align</span> <span class="dv">4</span>                                     <span class="co">; align at 4 bytes</span>
<span class="fu">kernel_stack:</span>                               <span class="co">; label points to beginning of memory</span>
    <span class="dt">resb</span> KERNEL_STACK_SIZE                  <span class="co">; reserve stack for the kernel</span></code></pre>
<p>Setting up the stack pointer is then trivial</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">esp</span>, kernel_stack + KERNEL_STACK_SIZE   <span class="co">; point esp to the start of the stack (end of memory area)</span></code></pre>
<h2 id="calling-c-code-from-assembly"><a href="#TOC"><span class="header-section-number">3.2</span> Calling C Code From Assembly</a></h2>
<p>The next step is to call a C function from the assembly code. There are many different calling conventions for how to call C code from assembly <span class="citation">[22]</span>, but we will use the <em>cdecl</em> calling convention, since it’s the one used by GCC. The cdecl calling convention states that arguments to a function should be passed via the stack (on x86). The arguments of the function should be pushed on the stack in a right-to-left order, that is, you push the rightmost argument first. The return value of the function is placed in the <code>eax</code> register. The following is an example</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> sum_of_three(<span class="dt">int</span> arg1, <span class="dt">int</span> arg2, <span class="dt">int</span> arg3)
{
    <span class="kw">return</span> arg1 + arg2 + arg3;
}</code></pre>
<pre class="sourceCode nasm"><code class="sourceCode nasm">external sum_of_three   <span class="co">; the function sum_of_three is defined elsewhere</span>

<span class="kw">push</span> <span class="dt">dword</span> <span class="dv">3</span>            <span class="co">; arg3</span>
<span class="kw">push</span> <span class="dt">dword</span> <span class="dv">2</span>            <span class="co">; arg2</span>
<span class="kw">push</span> <span class="dt">dword</span> <span class="dv">1</span>            <span class="co">; arg1</span>
<span class="kw">call</span> sum_of_three       <span class="co">; call the function, the result will be in eax</span></code></pre>
<h3 id="packing-structs"><a href="#TOC"><span class="header-section-number">3.2.1</span> Packing Structs</a></h3>
<p>In the rest of book, you will often come across “configuration bytes” that are a collection of bits in a very specific order. For example, a configuration could look like</p>
<pre><code>Bit:     | 31           16 | 15     8 | 7     0 |
Content: | address         | index    | config  |</code></pre>
<p>Instead of using an unsigned integer, <code>unsigned int</code>, for handling such configurations, it is much more convenient to use “packed structures”. When creating the following struct in C:</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> example {
    <span class="dt">unsigned</span> <span class="dt">char</span> config;
    <span class="dt">unsigned</span> <span class="dt">char</span> index;
    <span class="dt">unsigned</span> <span class="dt">short</span> address;
};</code></pre>
<p>there is no guarantee that the size of the <code>struct</code> will be exactly 32 bits, the compiler can add some padding in order to speed up element access. When using a <code>struct</code> to represent configuration bytes, it is very important that the size does <em>not</em> get padded, since the struct will eventually be treated as an unsigned integer by the hardware. To force GCC to <em>not</em> add any padding, the attribute <code>packed</code> can be used in the following way:</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> example {
    <span class="dt">unsigned</span> <span class="dt">char</span> config;
    <span class="dt">unsigned</span> <span class="dt">char</span> index;
    <span class="dt">unsigned</span> <span class="dt">short</span> address;
} __attribute__((packed));</code></pre>
<p>Note that <code>__attribute__((packed))</code> is not part of the C standard, so it might not work with all compilers (it works with GCC and Clang).</p>
<h2 id="compiling-c-code"><a href="#TOC"><span class="header-section-number">3.3</span> Compiling C Code</a></h2>
<p>When compiling the C code for the OS, quite a lot of flags to GCC has to be used. The reason for this is that the C code should <em>not</em> assume the presence of the standard library, since there is not standard library available in our OS. For more information about the flags, see the GCC manual. The flags used for compiling C are</p>
<pre><code>-m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector -nostartfiles
-nodefaultlibs</code></pre>
<p>As always when writing C programs, we recommend turning on all warnings and treat warnings as errors</p>
<pre><code>-Wall -Wextra -Werror</code></pre>
<p>You can now create a <code>kmain</code> function in a file called <code>kmain.c</code> that you can call from <code>loader.s</code>. At this point in time, <code>kmain</code> probably won’t need any arguments, but in later chapters it will.</p>
<h2 id="build-tools"><a href="#TOC"><span class="header-section-number">3.4</span> Build Tools</a></h2>
<p>Now is also probably a good time to set up some build tools to make it easier to compile and run the OS. We recommend using Make <span class="citation">[11]</span>, but there are plenty of other build systems available. A simple Makefile for the OS could look like the following</p>
<pre class="sourceCode Makefile"><code class="sourceCode makefile"><span class="dt">OBJECTS </span><span class="st">= loader.o kmain.o</span>
<span class="dt">CC </span><span class="st">= gcc</span>
<span class="dt">CFLAGS </span><span class="st">= -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector </span><span class="ch">\</span>
         <span class="ch">-</span><span class="bn">nostartfiles</span> -nodefaultlibs -Wall -Wextra -Werror -c
<span class="dt">LDFLAGS </span><span class="st">= -T link.ld -melf_i386</span>
<span class="dt">AS </span><span class="st">= nasm</span>
<span class="dt">ASFLAGS </span><span class="st">= -f elf</span>

<span class="dv">all:</span> kernel.elf

kernel.elf<span class="ch">:</span> <span class="ch">$(</span><span class="dt">OBJECTS</span><span class="ch">)</span>
    ld <span class="ch">$(</span><span class="dt">LDFLAGS</span><span class="ch">)</span> <span class="ch">$(</span><span class="dt">OBJECTS</span><span class="ch">)</span> -o kernel.elf

os.iso<span class="ch">:</span> kernel.elf
    cp kernel.elf iso/boot/kernel.elf
    genisoimage -R                              <span class="ch">\</span>
                <span class="ch">-</span><span class="bn">b</span> boot/grub/stage2_eltorito    <span class="ch">\</span>
                <span class="ch">-</span><span class="bn">no-emul-boot</span>                   <span class="ch">\</span>
                <span class="ch">-</span><span class="bn">boot-load-size</span> 4               <span class="ch">\</span>
                <span class="ch">-</span><span class="bn">A</span> os                           <span class="ch">\</span>
                <span class="ch">-</span><span class="bn">input-charset</span> utf8             <span class="ch">\</span>
                <span class="ch">-</span><span class="bn">quiet</span>                          <span class="ch">\</span>
                <span class="ch">-</span><span class="bn">boot-info-table</span>                <span class="ch">\</span>
                <span class="ch">-</span><span class="bn">o</span> os.iso                       <span class="ch">\</span>
                iso

<span class="dv">run:</span> os.iso
    bochs -f bochsrc.txt -q

<span class="ch">%</span>.o<span class="ch">:</span> <span class="ch">%</span>.c
    <span class="ch">$(</span><span class="dt">CC</span><span class="ch">)</span> <span class="ch">$(</span><span class="dt">CFLAGS</span><span class="ch">)</span>  <span class="ch">$</span>&lt; -o <span class="ch">$</span>@

<span class="ch">%</span>.o<span class="ch">:</span> <span class="ch">%</span>.s
    <span class="ch">$(</span><span class="dt">AS</span><span class="ch">)</span> <span class="ch">$(</span><span class="dt">ASFLAGS</span><span class="ch">)</span> <span class="ch">$</span>&lt; -o <span class="ch">$</span>@

<span class="dv">clean:</span>
    rm -rf <span class="ch">*</span>.o kernel.elf os.iso</code></pre>
<p>If your directory now looks like</p>
<pre><code>.
|-- bochsrc.txt
|-- iso
|   |-- boot
|     |-- grub
|       |-- menu.lst
|       |-- stage2_eltorito
|-- kmain.c
|-- loader.s</code></pre>
<p>then you should be able to start the OS in Bochs with the simple command</p>
<pre><code>make run</code></pre>
<h2 id="further-reading-1"><a href="#TOC"><span class="header-section-number">3.5</span> Further Reading</a></h2>
<ul>
<li>Kernigan &amp; Richies book, <em>The C Programming Language, Second Edition</em>, <span class="citation">[6]</span> is great for learning about all the aspects of C</li>
</ul>
<h1 id="output"><a href="#TOC"><span class="header-section-number">4</span> Output</a></h1>
<p>After booting our very small operating system kernel, the next task will be to be able to display text on the console. In this chapter we will create our first <em>drivers</em>, that is, code that acts as an layer between our kernel and the hardware, providing a nicer abstraction than speaking directly to the hardware. The first part of this chapter creates a driver for the framebuffer <span class="citation">[23]</span> to be able to display text to the user. The second part will create a driver for the serial port, since Bochs can store output from the serial port in a file, effectively creating a logging mechanism for our operating system!</p>
<h2 id="talking-to-the-hardware"><a href="#TOC"><span class="header-section-number">4.1</span> Talking to the Hardware</a></h2>
<p>There are usually two different ways to “talk” to the hardware, <em>memory-mapped I/O</em> and <em>I/O ports</em>.</p>
<p>If the hardware uses memory-mapped I/O, then you can write to a specific memory address and the hardware will be automatically get the new data. One example of this is the framebuffer, which will be discussed more in detail later. If you write the value <code>0x410F</code> to address <code>0x000B8000</code>, you will see the letter A in white color on a black background (see the section on <a href="#the-framebuffer">the framebuffer</a> for more details).</p>
<p>If the hardware uses I/O ports, then the assembly instructions <code>out</code> and <code>in</code> must be used to communicate with the device. <code>out</code> takes two parameters, the address of the I/O port and the value to send. <code>in</code> takes a single parameter, simply address of the I/O port and returns data. One can think of I/O ports as communicating with the hardware the same way as you communicate with a server using sockets. The cursor (the blinking rectangle) of the framebuffer is one example of hardware controlled via I/O ports.</p>
<h2 id="the-framebuffer"><a href="#TOC"><span class="header-section-number">4.2</span> The Framebuffer</a></h2>
<p>The framebuffer is a hardware device that is capable of displaying a buffer of memory on the screen <span class="citation">[23]</span>. The framebuffer has 80 columns and 25 rows, and their indices start at 0 (so rows are labelled 0 - 24).</p>
<h3 id="writing-text"><a href="#TOC"><span class="header-section-number">4.2.1</span> Writing Text</a></h3>
<p>Writing text to the console via the framebuffer is done by memory-mapped I/O. The starting address of memory-mapped I/O for the framebuffer is <code>0x000B8000</code>. The memory is divided into 16 bit cells, where the 16 bits determines both the character, the foreground color and the background color. The highest eight bits is the ASCII <span class="citation">[24]</span> value of the character, bit 7 - 3 the background and bit 3 - 0 the foreground, as can be seen in the following figure:</p>
<pre><code>Bit:     | 15 14 13 12 11 10 9 8 | 7 6 5 4 | 3 2 1 0 |
Content: | ASCII                 | FG      | BG      |</code></pre>
<p>The available colors are:</p>
<table>
<thead>
<tr class="header">
<th align="right">Color</th>
<th align="left">Value</th>
<th align="right">Color</th>
<th align="left">Value</th>
<th align="right">Color</th>
<th align="left">Value</th>
<th align="right">Color</th>
<th align="left">Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">Black</td>
<td align="left">0</td>
<td align="right">Red</td>
<td align="left">4</td>
<td align="right">Dark grey</td>
<td align="left">8</td>
<td align="right">Light red</td>
<td align="left">12</td>
</tr>
<tr class="even">
<td align="right">Blue</td>
<td align="left">1</td>
<td align="right">Magenta</td>
<td align="left">5</td>
<td align="right">Light blue</td>
<td align="left">9</td>
<td align="right">Light magenta</td>
<td align="left">13</td>
</tr>
<tr class="odd">
<td align="right">Green</td>
<td align="left">2</td>
<td align="right">Brown</td>
<td align="left">6</td>
<td align="right">Light green</td>
<td align="left">10</td>
<td align="right">Light brown</td>
<td align="left">14</td>
</tr>
<tr class="even">
<td align="right">Cyan</td>
<td align="left">3</td>
<td align="right">Light grey</td>
<td align="left">7</td>
<td align="right">Light cyan</td>
<td align="left">11</td>
<td align="right">White</td>
<td align="left">15</td>
</tr>
</tbody>
</table>
<p>The first cell corresponds to row zero, column zero on the console. Using an ASCII table, one can see that A corresponds to 65 or <code>0x41</code>. Therefore, to write the character A with a green foreground (2) and dark grey background (8) at place (0,0), the following assembly instruction is used</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> [<span class="bn">0x000B8000</span>]<span class="bn">, 0x4128</span></code></pre>
<p>The second cell then corresponds to row zero, column one and it’s address is</p>
<pre><code>0x000B8000 + 16 = 0x000B8010</code></pre>
<p>This can all be done a lot easier in C by treating the address <code>0x000B8000</code> as a char pointer, <code>char *fb = (char *) 0x000B8000</code>. Then, writing A to at place (0,0) with green foreground and dark grey background becomes:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">fb[<span class="dv">0</span>] = <span class="st">&#39;A&#39;</span><span class="co">;</span>
fb[<span class="dv">1</span>] = <span class="bn">0x28</span><span class="co">;</span></code></pre>
<p>This can of course be wrapped into a nice function</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/** </span>fb_write_cell:
 *  Writes a character with the given foreground and background to position i
 *  in the framebuffer.
 *
 *  <span class="kw">@param</span> i  The location in the framebuffer
 <span class="kw">*</span>  <span class="kw">@param</span> c  The character
 <span class="kw">*</span>  <span class="kw">@param</span> fg The foreground color
 <span class="kw">*</span>  <span class="kw">@param</span> bg The background color
 <span class="co">*/</span>
<span class="dt">void</span> fb_write_cell(<span class="dt">unsigned</span> <span class="dt">int</span> i, <span class="dt">char</span> c, <span class="dt">unsigned</span> <span class="dt">char</span> fg, <span class="dt">unsigned</span> <span class="dt">char</span> bg)
{
    fb[i] = c;
    fb[i + <span class="dv">1</span>] = ((fg &amp; <span class="bn">0x0F</span>) &lt;&lt; <span class="dv">4</span>) | (bg &amp; <span class="bn">0x0F</span>)
}</code></pre>
<p>which can then be used</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define FB_GREEN     2</span>
<span class="ot">#define FB_DARK_GREY 8</span>

fb_write_cell(<span class="dv">0</span>, &#39;A&#39;, FB_GREEN, FB_DARK_GREY);</code></pre>
<h3 id="moving-the-cursor"><a href="#TOC"><span class="header-section-number">4.2.2</span> Moving the Cursor</a></h3>
<p>Moving the cursor of the framebuffer is done via two different I/O ports. The cursor position is determined via a 16 bits integer, 0 means row zero, column zero, 1 means row zero, column one, 80 means row one, column zero and so on. Since the position is 16 bits large, and the <code>out</code> assembly instruction only take 8 bits as data, the position must be sent in two turns, first 8 bits then the next 8 bits. The framebuffer has two I/O ports, one for accepting the data, and one for describing the data being received. Port <code>0x3D4</code> is the command port that describes the data and port <code>0x3D5</code> is for the data itself.</p>
<p>To set the cursor at row one, column zero (position <code>80 = 0x0050</code>), one would use the following assembly instructions</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">out</span> <span class="bn">0x3D4</span>, <span class="dv">14</span>      <span class="co">; 14 tells the framebuffer to expect the highest 8 bits of the position</span>
<span class="kw">out</span> <span class="bn">0x3D5, 0x00    </span><span class="co">; sending the highest 8 bits of 0x0050</span>
<span class="kw">out</span> <span class="bn">0x3D4</span>, <span class="dv">15</span>      <span class="co">; 15 tells the framebuffer to expect the lowest 8 bits of the position</span>
<span class="kw">out</span> <span class="bn">0x3D5, 0x50    </span><span class="co">; sending the lowest 8 bits of 0x0050</span></code></pre>
<p>The <code>out</code> assembly instruction can’t be done in C, therefore it’s a good idea to wrap it an assembly function which can be accessed from C via the cdecl calling standard <span class="citation">[22]</span>:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">global</span> outb             <span class="co">; make the label outb visible outside this file</span>

<span class="co">; outb - send a byte to an I/O port</span>
<span class="co">; stack: [esp + 8] the data byte</span>
<span class="co">;        [esp + 4] the I/O port</span>
<span class="co">;        [esp    ] return address</span>
<span class="fu">outb:</span>
    <span class="kw">mov</span> <span class="kw">al</span>, [<span class="kw">esp</span> + <span class="dv">8</span>]    <span class="co">; move the data to be sent into the al register</span>
    <span class="kw">mov</span> <span class="kw">dx</span>, [<span class="kw">esp</span> + <span class="dv">4</span>]    <span class="co">; move the address of the I/O port into the dx register</span>
    <span class="kw">out</span> <span class="kw">dx</span>, <span class="kw">al</span>           <span class="co">; send the data to the I/O port</span>
    <span class="kw">ret</span>                  <span class="co">; return to the calling function</span></code></pre>
<p>By storing this function in a file called <code>io.s</code> and also creating a header <code>io.h</code>, the <code>out</code> assembly instruction can now be conveniently accessed from C:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#ifndef INCLUDE_IO_H</span>
<span class="ot">#define INCLUDE_IO_H</span>

<span class="co">/** </span>outb:
 *  Sends the given data to the given I/O port. Defined in io.s
 *
 *  <span class="kw">@param</span> port The I<span class="kw">/</span>O port to send the data to
 <span class="kw">*</span>  <span class="kw">@param</span> data The data to send to the I<span class="kw">/</span>O port
 <span class="co">*/</span>
<span class="dt">void</span> outb(<span class="dt">unsigned</span> <span class="dt">short</span> port, <span class="dt">unsigned</span> <span class="dt">char</span> data);

<span class="ot">#endif </span><span class="co">/* INCLUDE_IO_H */</span></code></pre>
<p>Moving the cursor can now be wrapped in a C function:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &quot;io.h&quot;</span>

<span class="co">/* The I/O ports */</span>
<span class="ot">#define FB_COMMAND_PORT         0x3D4</span>
<span class="ot">#define FB_DATA_PORT            0x3D5</span>

<span class="co">/* The I/O port commands */</span>
<span class="ot">#define FB_HIGH_BYTE_COMMAND    14</span>
<span class="ot">#define FB_LOW_BYTE_COMMAND     15</span>

<span class="co">/** </span>fb_move_cursor:
 *  Moves the cursor of the framebuffer to the given position
 *
 *  <span class="kw">@param</span> pos The new position of the cursor
 <span class="co">*/</span>
<span class="dt">void</span> fb_move_cursor(<span class="dt">unsigned</span> <span class="dt">short</span> pos)
{
    outb(FB_COMMAND_PORT, FB_HIGH_BYTE_COMMAND);
    outb(FB_DATA_PORT,    ((pos &gt;&gt; <span class="dv">8</span>) &amp; <span class="bn">0x00FF</span>));
    outb(FB_COMMAND_PORT, FB_LOW_BYTE_COMMAND);
    outb(FB_DATA_PORT,    pos &amp; <span class="bn">0x00FF</span>);
}</code></pre>
<h3 id="the-driver"><a href="#TOC"><span class="header-section-number">4.2.3</span> The Driver</a></h3>
<p>Now that the basic functions, it’s time to think about a driver interface for the framebuffer. There is no right or wrong about what functionality the interface should provide, but one suggestion is to have a <code>write</code> function with the declaration</p>
<pre><code>int write(char *buf, unsigned int len);</code></pre>
<p>that writes the contents of the buffer to the screen. The <code>write</code> function would automatically advance the cursor after a character has been written and also scroll the screen if necessary.</p>
<h2 id="the-serial-ports"><a href="#TOC"><span class="header-section-number">4.3</span> The Serial Ports</a></h2>
<p>The serial port <span class="citation">[25]</span> is an interface for communicating between hardware devices, and it’s usually not available on modern computers. However, the serial port is easy to use, and more importantly, can be used as a logging utility together with Bochs. A computer usually has several serial ports, but we will only make use of one of the ports, since we only will use it for logging. Furthermore, we will only use it for output, not input. The serial ports are controlled completely via I/O ports.</p>
<h3 id="configuring-the-serial-port"><a href="#TOC"><span class="header-section-number">4.3.1</span> Configuring the Serial Port</a></h3>
<p>The first data that needs to be sent to the serial port is some configuration data. In order for two hardware devices to be able to talk each other, they must agree upon some things. These things include:</p>
<ul>
<li>The speed used when sending data (bit or baud rate)</li>
<li>If any error checking is used for the data (parity bit, stop bits)</li>
<li>The number of bits that represents a unit of data (data bits)</li>
</ul>
<h3 id="configuring-the-line"><a href="#TOC"><span class="header-section-number">4.3.2</span> Configuring the Line</a></h3>
<p>Configuring the line means to configure how data is being sent over the line. The serial port has an I/O port, the <em>line command port</em> that is used for configuring the line.</p>
<p>First, the speed for sending data will be set. The serial port has an internal clock that runs at 115200 Hz. Setting the speed means sending a divisor to the serial port, for example sending 2 results in a speed of <code>115200 / 2 = 57600</code> Hz.</p>
<p>The divisor is a 16 bit number, but we can only send 8 bits at a time. Therefore, we must first send an instruction telling the serial port to expect first the highest 8 bits, then the lowest. This is done by sending <code>0x80</code> to the send line command port. The code then becomes:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &quot;io.h&quot; </span><span class="co">/* io.h is implement in the section &quot;Moving the cursor&quot; */</span>

<span class="co">/* The I/O ports */</span>

<span class="co">/* All the I/O ports are calculated relative to the data port. This is because</span>
<span class="co"> * all serial ports (COM1, COM2, COM3, COM4) have their ports in the same</span>
<span class="co"> * order, but they start at different values.</span>
<span class="co"> /</span>

<span class="co">#define SERIAL_COM1_BASE                0x3F8      /* COM1 base port */</span>

<span class="ot">#define SERIAL_DATA_PORT(base)          (base)</span>
<span class="ot">#define SERIAL_FIFO_COMMAND_PORT(base)  (base + 2)</span>
<span class="ot">#define SERIAL_LINE_COMMAND_PORT(base)  (base + 3)</span>
<span class="ot">#define SERIAL_MODEM_COMMAND_PORT(base) (base + 4)</span>
<span class="ot">#define SERIAL_LINE_STATUS_PORT(base)   (base + 5)</span>

<span class="co">/* The I/O port commands */</span>

<span class="co">/* SERIAL_LINE_ENABLE_DLAB:</span>
<span class="co"> * Tells the serial port to expect first the highest 8 bits on the data port,</span>
<span class="co"> * then the lowest 8 bits will follow</span>
<span class="co"> */</span>
<span class="ot">#define SERIAL_LINE_ENABLE_DLAB         0x80</span>

<span class="co">/** </span>serial_configure_baud_rate:
 *  Sets the speed of the data being sent. The <span class="kw">default</span> speed of a serial
 *  port is <span class="dv">115200</span> bits/s. The argument is a divisor of that number, hence
 *  the resulting speed becomes (<span class="dv">115200</span> / divisor) bits/s.
 *
 *  <span class="kw">@param</span> com      The COM port to configure
 <span class="kw">*</span>  <span class="kw">@param</span> divisor  The divisor
 <span class="co">*/</span>
<span class="dt">void</span> serial_configure_baud_rate(<span class="dt">unsigned</span> <span class="dt">short</span> com, <span class="dt">unsigned</span> <span class="dt">short</span> divisor)
{
    outb(SERIAL_LINE_COMMAND_PORT(com),
         SERIAL_LINE_ENABLE_DLAB);
    outb(SERIAL_DATA_PORT(com),
         (divisor &gt;&gt; <span class="dv">8</span>) &amp; <span class="bn">0x00FF</span>);
    outb(SERIAL_DATA_PORT(com),
         divisor &amp; <span class="bn">0x00FF</span>);
}</code></pre>
<p>Next, the way data is being sent must be configured, this is also done via the line command port by sending 8 bits. The layout of the 8 bits are as follows</p>
<pre><code>Bit:     | 7 | 6 | 5 4 3 | 2 | 1 0 |
Content: | d | b | prty  | s | exp |</code></pre>
<p>The content is</p>
<table>
<thead>
<tr class="header">
<th align="right">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">d</td>
<td align="left">Enables (<code>d = 1</code>) or disables (<code>d = 0</code>) DLAB</td>
</tr>
<tr class="even">
<td align="right">b</td>
<td align="left">If break control is enabled (<code>b = 1</code>) or disabled (<code>b = 0</code>)</td>
</tr>
<tr class="odd">
<td align="right">prty</td>
<td align="left">The number of parity bits to use (<code>prty = 0, 1, 2 or 3</code>)</td>
</tr>
<tr class="even">
<td align="right">s</td>
<td align="left">The number of stop bits to use (<code>s = 0</code> equals 1, <code>s = 1</code> equals 1.5 or 2)</td>
</tr>
<tr class="odd">
<td align="right">exp</td>
<td align="left">Describes the length of the data, the length is <code>2^exp</code> (<code>exp = 3</code> results in 8 bits)</td>
</tr>
</tbody>
</table>
<p>We will use the mostly standard value <code>0x03</code> <span class="citation">[26]</span>, meaning a length of 8 bits, no parity bit, one stop bit and break control disabled. This is sent to the line command port, resulting in</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/** </span>serial_configure_line:
 *  Configures the line of the given serial port. The port is set to have a
 *  data length of <span class="dv">8</span> bits, no parity bits, one stop bit and <span class="kw">break</span> control
 *  disabled.
 *
 *  <span class="kw">@param</span> com  The serial port to configure
 <span class="co">*/</span>
<span class="dt">void</span> serial_configure_line(<span class="dt">unsigned</span> <span class="dt">short</span> com)
{
    <span class="co">/* Bit:     | 7 | 6 | 5 4 3 | 2 | 1 0 |</span>
<span class="co">     * Content: | d | b | prty  | s | exp |</span>
<span class="co">     * Value:   | 0 | 0 | 0 0 0 | 0 | 1 1 | = 0x03</span>
<span class="co">     */</span>
    outb(SERIAL_LINE_COMMAND_PORT(com), <span class="bn">0x03</span>);
}</code></pre>
<p>For a more in-depth explanation of the values, see <span class="citation">[26]</span>.</p>
<h3 id="configuring-the-fifo-queues"><a href="#TOC"><span class="header-section-number">4.3.3</span> Configuring the FIFO Queues</a></h3>
<p>When data is transmitted via the serial port, it is placed in buffers, both when receiving and sending data. This way, if you send data to the serial port faster than it can send it over the wire, it will be buffered. However, if you send too much data too fast, the buffer will be full and then data will be dropped. The FIFO queue configuration byte looks like</p>
<pre><code>Bit:     | 7 6 | 5  | 4 | 3   | 2   | 1   | 0 |
Content: | lvl | bs | r | dma | clt | clr | e |</code></pre>
<p>The content is</p>
<table>
<thead>
<tr class="header">
<th align="right">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">lvl</td>
<td align="left">How many bytes should be stored in the FIFO buffers</td>
</tr>
<tr class="even">
<td align="right">bs</td>
<td align="left">If the buffers should 16 or 64 bytes large</td>
</tr>
<tr class="odd">
<td align="right">r</td>
<td align="left">Reserved</td>
</tr>
<tr class="even">
<td align="right">dma</td>
<td align="left">How the serial port data should be accessed</td>
</tr>
<tr class="odd">
<td align="right">clt</td>
<td align="left">Clear the transmission FIFO buffer</td>
</tr>
<tr class="even">
<td align="right">clr</td>
<td align="left">Clear the receiver FIFO buffer</td>
</tr>
<tr class="odd">
<td align="right">e</td>
<td align="left">If the FIFO buffer should be enabled or not</td>
</tr>
</tbody>
</table>
<p>We use the value <code>0xC7 = 11000111</code> that:</p>
<pre><code>- Enables FIFO
- Clear both receiver and transmission FIFO queues
- Use 14 bytes as size of queue</code></pre>
<p>For a more in-depth explanation of the values, see <span class="citation">[27]</span></p>
<h3 id="configuring-the-modem"><a href="#TOC"><span class="header-section-number">4.3.4</span> Configuring the modem</a></h3>
<p>The modem control register is used for very simple hardware flow control via the Ready To Transmit (RTS) and Data Terminal Ready (DTR) pins. When configuring the serial port before sending data, we want RTS and DTR to be 1.</p>
<p>The modem configuration byte looks like</p>
<pre><code>Bit:     | 7 | 6 | 5  | 4  | 3   | 2   | 1   | 0   |
Content: | r | r | af | lb | ao2 | ao1 | rts | dtr |</code></pre>
<p>The contents is</p>
<table>
<thead>
<tr class="header">
<th align="right">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">r</td>
<td align="left">Reserved</td>
</tr>
<tr class="even">
<td align="right">af</td>
<td align="left">Autoflow control enabled</td>
</tr>
<tr class="odd">
<td align="right">lb</td>
<td align="left">Loopback mode (used for debugging serial ports)</td>
</tr>
<tr class="even">
<td align="right">ao2</td>
<td align="left">Auxiliary output 2, used for receiving interrupts</td>
</tr>
<tr class="odd">
<td align="right">ao1</td>
<td align="left">Auxiliary output 1</td>
</tr>
<tr class="even">
<td align="right">rts</td>
<td align="left">Ready To Transmit</td>
</tr>
<tr class="odd">
<td align="right">dtr</td>
<td align="left">Data Terminal Ready</td>
</tr>
</tbody>
</table>
<p>Since we don’t need interrupts, because we won’t handle any received data, we use the configuration value <code>0x03 = 00000011</code>, that is, RTS is set to 1 and DTR is set to 1.</p>
<h3 id="writing-to-the-serial-port"><a href="#TOC"><span class="header-section-number">4.3.5</span> Writing to the Serial Port</a></h3>
<p>Writing to the serial port is done via the data I/O port. However, before writing, we must first ensure that the transmit FIFO queue is empty (so that all previous writes has been done). This is done by checking bit 5 of the line status I/O port.</p>
<p>Reading the contents of an I/O port is done via the <code>in</code> assembly instruction. There is no way to use the <code>in</code> instruction from C, so it has to be wrapped (the same way as the <code>out</code> instruction):</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">global</span> inb

<span class="co">; inb - returns a byte from the given I/O port</span>
<span class="co">; stack: [esp + 4] The address of the I/O port</span>
<span class="co">;        [esp    ] The return address</span>
<span class="fu">inb:</span>
    <span class="kw">mov</span> <span class="kw">dx</span>, [<span class="kw">esp</span> + <span class="dv">4</span>]       <span class="co">; move the address of the I/O port to the dx register</span>
    <span class="kw">in</span>  <span class="kw">al</span>, <span class="kw">dx</span>              <span class="co">; read a byte from the I/O port and store it in the al register</span>
    <span class="kw">ret</span>                     <span class="co">; return the read byte</span></code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* in file io.h */</span>

<span class="co">/** </span>inb:
 *  Read a byte from an I/O port.
 *
 *  <span class="kw">@param</span> port The address of the I<span class="kw">/</span>O port
 <span class="kw">*</span>  <span class="kw">@return</span>     The read byte
 <span class="co">*/</span>
<span class="dt">unsigned</span> <span class="dt">char</span> inb(<span class="dt">unsigned</span> <span class="dt">short</span> port);</code></pre>
<p>Checking if the transmit FIFO is empty can now be done from C:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &quot;io.h&quot;</span>

<span class="co">/** </span>serial_is_transmit_fifo_empty:
 *  Checks whether the transmit FIFO queue is empty or not <span class="kw">for</span> the given COM
 *  port.
 *
 *  <span class="kw">@param</span> com The COM port
 <span class="kw">*</span>  <span class="kw">@return</span> <span class="dv">0</span> <span class="kw">if</span> the transmit FIFO queue is not empty
 *          <span class="dv">1</span> <span class="kw">if</span> the transmit FIFO is empty
 <span class="co">*/</span>
<span class="dt">int</span> serial_is_transmit_fifo_empty(<span class="dt">unsigned</span> <span class="dt">int</span> com)
{
    <span class="co">/* 0x20 = 0001 0000 */</span>
    <span class="kw">return</span> inb(SERIAL_LINE_STATUS_PORT(com)) &amp; <span class="bn">0x20</span>;
}</code></pre>
<p>Now, the writing to serial port means spinning while the transmit FIFO queue isn’t empty, and then writing to the data port.</p>
<h3 id="configuring-bochs"><a href="#TOC"><span class="header-section-number">4.3.6</span> Configuring Bochs</a></h3>
<p>To use the serial port together with Bochs, you must tell Bochs via the <code>bochsrc.txt</code> file to save the output from the serial port to a file. This can be done with the <code>com1</code> config parameter:</p>
<pre><code>com1: enabled=1, mode=file, dev=com1.out&quot;</code></pre>
<p>The output will now be stored in the <code>com1.out</code> file.</p>
<h3 id="the-driver-1"><a href="#TOC"><span class="header-section-number">4.3.7</span> The Driver</a></h3>
<p>We recommend that you try to write a <code>printf</code> like function, see section 7.3 in <span class="citation">[6]</span>. We also recommend that you create some way of distinguish the severeness of log message, for example by prepending the messages with <code>DEBUG</code>, <code>INFO</code> or <code>ERROR</code>.</p>
<h2 id="further-reading-2"><a href="#TOC"><span class="header-section-number">4.4</span> Further Reading</a></h2>
<ul>
<li>The book “Serial programming” (available on WikiBooks) has a great section on programming the serial port, <a href="http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming#UART_Registers"><code class="url">http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming#UART_Registers</code></a></li>
<li>The OSDev wiki has a page with a lot of information about the serial ports, <a href="http://wiki.osdev.org/Serial_ports"><code class="url">http://wiki.osdev.org/Serial_ports</code></a></li>
</ul>
<h1 id="segmentation"><a href="#TOC"><span class="header-section-number">5</span> Segmentation</a></h1>
<p>Segmentation in x86 means accessing the memory through segments. Segments are portions of the address space, possibly overlapping, specified by a base address and a limit. To address a byte in segmented memory, you use a 48-bit <em>logical address</em>: 16 bits that specifies the segment, and 32-bits to specify what offset within that segment you want. The offset is added to the base address of the segment, and the resulting linear address is checked against the segment’s limit - see the figure below. If everything works out fine, (including access-right checks ignored for now), the results is a <em>linear address</em>. If paging is disabled (see the chapter on <a href="#paging">paging</a>, this linear address space is mapped 1:1 on the <em>physical address</em> space, and the physical memory can be accessed.</p>
<div class="figure">
<img src="images/intel_3_5_logical_to_linear.png" alt="Translation of logical addresses to linear addresses." /><p class="caption">Translation of logical addresses to linear addresses.</p>
</div>
<p>To enable segmentation you need to set up a table that describes each segment - a segment descriptor table. In x86, there are two types of descriptor tables: The global descriptor table (GDT) and local descriptor tables (LDT). An LDT is set up and managed by user-space processes, and each process have their own LDT. LDT’s can be used if a more complex segmentation model is desired - we won’t use it. The GDT shared by everyone - it’s global.</p>
<h2 id="accessing-memory"><a href="#TOC"><span class="header-section-number">5.1</span> Accessing Memory</a></h2>
<p>Most of the time when we access memory we don’t have to explicitly specify the segment we want to use. The processor has six 16-bit segment registers: <code>cs</code>, <code>ss</code>, <code>ds</code>, <code>es</code>, <code>gs</code> and <code>fs</code>. <code>cs</code> is the code segment register and specifies the segment to use when fetching instructions. <code>ss</code> is used whenever the accessing the stack (through the stack pointer <code>esp</code>), and <code>ds</code> is used for other data accesses. <code>es</code>, <code>gs</code> and <code>fs</code> are free to use however we or the user processes wish (we will set them, but not use them).</p>
<p>Implicit use of segment registers:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="fu">func:</span>
    <span class="kw">mov</span> <span class="kw">eax</span>, [<span class="kw">esp</span><span class="dv">+4</span>]
    <span class="kw">mov</span> <span class="kw">ebx</span>, [<span class="kw">eax</span>]
    <span class="kw">add</span> <span class="kw">ebx</span>, <span class="dv">8</span>
    <span class="kw">mov</span> [<span class="kw">eax</span>], <span class="kw">ebx</span>
    <span class="kw">ret</span></code></pre>
<p>Explicit version:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="fu">func:</span>
    <span class="kw">mov</span> <span class="kw">eax</span>, [<span class="kw">ss</span>:<span class="kw">esp</span><span class="dv">+4</span>]
    <span class="kw">mov</span> <span class="kw">ebx</span>, [<span class="kw">ds</span>:<span class="kw">eax</span>]
    <span class="kw">add</span> <span class="kw">ebx</span>, <span class="dv">8</span>
    <span class="kw">mov</span> [<span class="kw">ds</span>:<span class="kw">eax</span>], <span class="kw">ebx</span>
    <span class="kw">ret</span></code></pre>
<p>(You don’t need to use <code>ss</code> for storing the stack segment selector, or <code>ds</code> for the data segment selector, but it is convenient, and makes it possible to use the implicit style above.)</p>
<p>Segment descriptors and their fields are described in figure 3-8 in the Intel manual <span class="citation">[28]</span>.</p>
<h2 id="the-global-descriptor-table-gdt"><a href="#TOC"><span class="header-section-number">5.2</span> The Global Descriptor Table (GDT)</a></h2>
<p>A GDT/LDT is an array of 8-byte segment descriptors. The first descriptor in the GDT is always a null descriptor, and can never be used to access memory. We need at least two segment descriptors (plus the null descriptor) for our GDT (and two more later when we enter <a href="#user-mode">user mode</a>, see the <a href="#segments-for-user-mode">segments for user mode</a> section). This is because the descriptor contains more information than just the base and limit fields. The two most relevant fields here are the <em>Type</em> field and the <em>Descriptor Privilege Level</em> (DPL) field.</p>
<p>The table 3-1, chapter 3, in the Intel manual <span class="citation">[28]</span> specifies the values for the Type field, and it is because of this that we need at least two segments: One segment to execute code (to put in <code>cs</code>) (Execute-only or Execute-Read) and one to read and write data (Read/Write) (to put in the other segment registers).</p>
<p>The DPL specifies the privilege levels required to execute in this segment. x86 allows for four privilege levels (PL), 0 to 3, where PL0 is the most privileged. In most operating systems (eg. Linux and Windows), only PL0 and PL3 are used (although MINIX uses all levels). The kernel should be able to do anything, so it “runs in PL0” (uses segments with DPL set to 0), and user-mode processes should run in PL3. The current privilege level (CPL) is determined by the segment selector in <code>cs</code>.</p>
<p>Since we are now executing in kernel mode (PL0), the DPL should be 0. The segments we need are described in the table below.</p>
<table>
<caption>The segment descriptors needed.</caption>
<thead>
<tr class="header">
<th align="right">Index</th>
<th align="right">Offset</th>
<th align="left">Name</th>
<th align="left">Address range</th>
<th align="left">Type</th>
<th align="left">DPL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right"><code>0x00</code></td>
<td align="left">null descriptor</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right"><code>0x08</code></td>
<td align="left">kernel code segment</td>
<td align="left"><code>0x00000000 - 0xFFFFFFFF</code></td>
<td align="left">RX</td>
<td align="left">PL0</td>
</tr>
<tr class="odd">
<td align="right">2</td>
<td align="right"><code>0x10</code></td>
<td align="left">kernel data segment</td>
<td align="left"><code>0x00000000 - 0xFFFFFFFF</code></td>
<td align="left">RW</td>
<td align="left">PL0</td>
</tr>
</tbody>
</table>
<p>Note that the segments overlap - they both encompass the entire linear address space. In our minimal setup we’ll only use segmentation to get privilege levels. See the <span class="citation">[28]</span>, chapter 3, for details on the other descriptor fields.</p>
<h2 id="creating-and-loading-the-gdt"><a href="#TOC"><span class="header-section-number">5.3</span> Creating and Loading the GDT</a></h2>
<p>Creating the GDT can be done both in C and assembly. A static fixed-size array should do the trick.</p>
<p>To load the GDT into the processor we use the <code>lgdt</code> instruction, which takes the address of a struct that specifies the start and size of the GDT:</p>
<pre><code>32-bit: start of GDT
16-bit: size of GDT (8 bytes * num entries)</code></pre>
<p>It is easiest to encode this information using a “packed struct”.</p>
<p>If <code>eax</code> has an address to such a struct, we can just to the following:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">lgdt</span> [<span class="kw">eax</span>]</code></pre>
<p>It might be easier if you make this instruction available from C, the same way as was done with <code>in</code> and <code>out</code>.</p>
<p>Now that the processor knows where to look for the segment descriptors we need to load the segment registers with the corresponding segment selectors. The content of a segment selector is described in the table below.</p>
<pre><code>Bit:     | 15                                3 | 2  | 1 0 |
Content: | offset (index)                      | ti | rpl |</code></pre>
<table>
<caption>The layout of segment selectors.</caption>
<col width="23%" />
<col width="76%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">rpl</td>
<td align="left">Requested Privilege Level - we want to execute in PL0 for now.</td>
</tr>
<tr class="even">
<td align="left">ti</td>
<td align="left">Table Indicator. 0 means that this specifies a GDT segment, 1 means an LDT Segment.</td>
</tr>
<tr class="odd">
<td align="left">offset (index)</td>
<td align="left">Offset within descriptor table.</td>
</tr>
</tbody>
</table>
<p>The offset is added to the start of the GDT to get the address of the segment descriptor: <code>0x08</code> for the first descriptor and <code>0x10</code> for the second, since each descriptor is 8 bytes. The Requested Privilege Level (RPL) should be <code>0</code>, since we want to remain in PL0.</p>
<p>Loading the segment selector registers is easy for the data registers - just copy the correct offsets into the registers:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">mov</span> <span class="kw">ds</span><span class="bn">, 0x10</span>
<span class="kw">mov</span> <span class="kw">ss</span><span class="bn">, 0x10</span>
<span class="kw">mov</span> <span class="kw">es</span><span class="bn">, 0x10</span>
<span class="co">; ...</span></code></pre>
<p>To load <code>cs</code> we have to do a “far jump”:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm">    <span class="co">; using previous cs</span>
    <span class="kw">jmp</span> <span class="bn">0x08</span>:flush_cs

<span class="fu">flush_cs:</span>
    <span class="co">; now we&#39;ve changed cs to 0x08</span></code></pre>
<p>A far jump is a jump where we explicitly specify the full 48-bit logical address: The segment selector to use, and the absolute address to jump to. It will first set <code>cs</code> to <code>0x08</code>, and then jump to <code>.flush_cs</code> using its absolute address.</p>
<p>Whenever we load a new segment selector into a segment register, the processor reads the entire descriptor and stores it in shadow registers within the processor.</p>
<h2 id="further-reading-3"><a href="#TOC"><span class="header-section-number">5.4</span> Further Reading</a></h2>
<ul>
<li>Chapter 3 of the Intel manual <span class="citation">[28]</span> is quite good; low-level and technical.</li>
<li>The OSDev wiki can be useful: <a href="http://wiki.osdev.org/Segmentation"><code class="url">http://wiki.osdev.org/Segmentation</code></a></li>
<li>The Wikipedia page on x86 segmentation might be worth looking into: <a href="http://en.wikipedia.org/wiki/X86_memory_segmentation"><code class="url">http://en.wikipedia.org/wiki/X86_memory_segmentation</code></a></li>
</ul>
<h1 id="interrupts-and-input"><a href="#TOC"><span class="header-section-number">6</span> Interrupts and Input</a></h1>
<p>Now that the OS can produce <em>output</em>, it would be nice if it also could get some <em>input</em>. In order to read information from the keyboard, the operating system must be able to handle <em>interrupts</em>. An interrupt occurs when a hardware device, such as the keyboard, the serial port or the timer, signals the CPU that the state of the device has changed. The CPU itself can also send interrupts due to program errors, for example when a program references memory it doesn’t has access to, or when a program divides a number by zero. Finally, there are also <em>software intterupts</em>, which are interrupts that are caused by the <code>int</code> assembly instruction, and they are often used for system calls (syscalls).</p>
<h2 id="interrupts-handlers"><a href="#TOC"><span class="header-section-number">6.1</span> Interrupts Handlers</a></h2>
<p>Interrupts are handled via the <em>interrupt descriptor table</em> (IDT). The IDT that describes a handler for each interrupt. Each interrupt has a number (0 - 255), and the handler for interrupt <em>i</em> is defined at the <em>i:th</em> position in the table. There are three different kinds of handlers for interrupts:</p>
<ul>
<li>Task handler</li>
<li>Interrupt handler</li>
<li>Trap handler</li>
</ul>
<p>The task handler uses Intel specific functionality, so they won’t be covered here (see the Intel manual <span class="citation">[28]</span>, chapter 6, for more info). The only difference between an interrupt handler and a trap handler is that the interrupt handler disables interrupts, that is, you can’t get an interrupt while at the same time handling an interrupt. In this book, we will use trap handlers and disables interrupts manually when we need to.</p>
<h2 id="creating-an-entry-in-the-idt"><a href="#TOC"><span class="header-section-number">6.2</span> Creating an Entry in the IDT</a></h2>
<p>An entry in the IDT for an interrupt handler consists of 64 bits. The highest 32 bits are</p>
<pre><code>Bit:     | 31              16 | 15 | 14 13 | 12 | 11 | 10 9 8 | 7 6 5 | 4 3 2 1 0 |
Content: | offset high        | P  | DPL   | 0  | D  | 1  1 0 | 0 0 0 | reserved  |</code></pre>
<p>and the lowest 32 bits are</p>
<pre><code>Bit:     | 31              16 | 15              0 |
Content: | segment selector   | offset low        |</code></pre>
<p>where the content is</p>
<table>
<thead>
<tr class="header">
<th align="right">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">offset high</td>
<td align="left">The 16 highest bits of the 32 bit address in the segment</td>
</tr>
<tr class="even">
<td align="right">offset low</td>
<td align="left">The 16 lowest bits of the 32 bits address in the segment</td>
</tr>
<tr class="odd">
<td align="right">p</td>
<td align="left">If the handler is present in memory or not (1 = present, 0 = not present)</td>
</tr>
<tr class="even">
<td align="right">DPL</td>
<td align="left">Descriptor Privilige Level, the privilege level the handler can be called from (0, 1, 2, 3)</td>
</tr>
<tr class="odd">
<td align="right">D</td>
<td align="left">Size of gate, (1 = 32 bits, 0 = 16 bits)</td>
</tr>
<tr class="even">
<td align="right">segment selector</td>
<td align="left">The index in the GDT</td>
</tr>
<tr class="odd">
<td align="right">r</td>
<td align="left">Reserved</td>
</tr>
</tbody>
</table>
<p>The offset is a pointer to code (preferably an assembly label). For example, to create an entry for a handler which code starts at <code>0xDEADBEEF</code> that runs in privilege level 0 (same as the kernel) and therefore uses the same code segment selector as the kernel, the following two bytes would be used:</p>
<pre><code>0xDEAD8E00
0x0008BEEF</code></pre>
<p>If the IDT then is represented an <code>unsigned integer idt[256];</code> then to register this as the handler for interrupt 0 (divide error), you would write</p>
<pre class="sourceCode c"><code class="sourceCode c">idt[<span class="dv">0</span>] = <span class="bn">0xDEAD8E00</span>
idt[<span class="dv">1</span>] = <span class="bn">0x0008BEEF</span></code></pre>
<p>As written in the chapter <a href="#getting-to-c">getting to C</a>, we recommend that you instead of using bytes (or unsigned integers) use packed structures to make the code more readable.</p>
<h2 id="creating-a-generic-interrupt-handler"><a href="#TOC"><span class="header-section-number">6.3</span> Creating a Generic Interrupt Handler</a></h2>
<p>When the interrupt occurs, the CPU will push information about the interrupt on the stack, then look up the appropriate interrupt hander in the IDT and jump to it. Once the interrupt handler is done, it uses the <code>iret</code> instruction to return. <code>iret</code> pops the information from the stack, restores EFLAGS and jumps to <code>CS:EIP</code>.</p>
<p>The stack at the time of the interrupt will look like</p>
<pre><code>[esp + 12] EFLAGS
[esp + 8]  CS
[esp + 4]  EIP
[esp]      Error code?</code></pre>
<p>The reason for the question mark behind error code is because not all interrupts creates an error code. The CPU interrupts that put an error code on the stack are 8, 10, 11, 12, 13, 14 and 17.</p>
<p>The interrupt handler has to be written in assembly, because the all the registers has to be pushed on the stack, because the code that got interrupted will assume that the state of its registers hasn’t changed. Writing all the logic of the interrupt handler in assembly will be tiresome, so creating an assembly handler that saves the registers, calls a C function, restores the registers and returns is a good idea!</p>
<p>The C handler should get the state of the registers, the state of the stack and the number of the interrupt. The following definitions can for example be used:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> cpu_state {
    <span class="dt">unsigned</span> <span class="dt">int</span> eax;
    <span class="dt">unsigned</span> <span class="dt">int</span> ebx;
    <span class="dt">unsigned</span> <span class="dt">int</span> ecx;
    .
    .
    .
    <span class="dt">unsigned</span> <span class="dt">int</span> esp;
} __attribute__((packed));

<span class="kw">struct</span> stack_state {
    <span class="dt">unsigned</span> <span class="dt">int</span> error_code;
    <span class="dt">unsigned</span> <span class="dt">int</span> eip;
    <span class="dt">unsigned</span> <span class="dt">int</span> cs;
    <span class="dt">unsigned</span> <span class="dt">int</span> eflags;
} __attribute__((packed));

<span class="dt">void</span> interrupt_handler(<span class="kw">struct</span> cpu_state cpu, <span class="dt">unsigned</span> <span class="dt">int</span> interrupt, <span class="kw">struct</span> stack_state stack);</code></pre>
<p>Unfortunately, the CPU does <em>not</em> push the interrupt number on the stack. Since writing one version for each interrupt is tedious, it’s better to use the macro functionality of NASM (see <span class="citation">[29]</span> for more details). Since not all interrupts produce an error code, the error code 0 will be used for interrupts without error code.</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="ot">%macro no_error_code_interrupt_handler %1</span>
<span class="kw">global</span> interrupt_handler_<span class="ot">%1</span>
interrupt_handler_<span class="ot">%1:</span>
    <span class="kw">push</span>    <span class="dt">dword</span> <span class="dv">0</span>                     <span class="co">; push 0 as error code</span>
    <span class="kw">push</span>    <span class="dt">dword</span> <span class="ot">%1                    ; push the interrupt number</span>
    <span class="kw">jmp</span>     common_interrupt_handler    <span class="co">; jump to the common handler</span>
<span class="ot">%endmacro</span>

<span class="ot">%macro error_code_interrupt_handler %1</span>
<span class="kw">global</span> interrupt_handler_<span class="ot">%1</span>
interrupt_handler_<span class="ot">%1:</span>
    <span class="kw">push</span>    <span class="dt">dword</span> <span class="ot">%1                    ; push the interrupt number</span>
    <span class="kw">jmp</span>     common_interrupt_handler    <span class="co">; jump to the common handler</span>
<span class="ot">%endmacro</span>

<span class="fu">common_interrupt_handler:</span>               <span class="co">; the common parts of the generic interrupt handler</span>
    <span class="co">; save the registers</span>
    <span class="kw">push</span>    <span class="kw">eax</span>
    <span class="kw">push</span>    <span class="kw">ebx</span>
    .
    .
    .
    <span class="kw">push</span>    <span class="kw">ebp</span>

    <span class="co">; call the C function</span>
    <span class="kw">call</span>    interrupt_handler

    <span class="co">; restore the registers</span>
    <span class="kw">pop</span>     <span class="kw">ebp</span>
    .
    .
    .
    <span class="kw">pop</span>     <span class="kw">ebx</span>
    <span class="kw">pop</span>     <span class="kw">eax</span>

    <span class="co">; restore the esp</span>
    <span class="kw">add</span>     <span class="kw">esp</span>, <span class="dv">8</span>

    <span class="co">; return to the code that got interrupted</span>
    <span class="kw">iret</span>

no_error_code_interrupt_handler <span class="dv">0</span>       <span class="co">; create handler for interrupt 0</span>
no_error_code_interrupt_handler <span class="dv">1</span>       <span class="co">; create handler for interrupt 1</span>
.
.
.
error_code_handler              <span class="dv">7</span>       <span class="co">; create handler for interrupt 7</span>
.
.
.</code></pre>
<p>The <code>common_interrupt_handler</code> does the following: - Push the registers onto the stack - Call the C function <code>interrupt_handler</code> - Pop the registers from the stack - Add 8 to <code>esp</code> (due to the error code and the interrupt number) - Execute <code>iret</code> to return to the interrupted code</p>
<p>Since the macros declares global labels, the addresses of the interrupt handlers can be accessed from C or assembly when creating the IDT.</p>
<h2 id="loading-the-idt"><a href="#TOC"><span class="header-section-number">6.4</span> Loading the IDT</a></h2>
<p>The IDT is loaded with <code>lidt</code> assembly instruction which takes the address of the first element in the array. It is easiest to wrap this instruction and instead use it from C:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">global</span>  load_idt

<span class="co">; load_idt - Loads the interrupt descriptor table (IDT).</span>
<span class="co">; stack: [esp + 4] the address of the first entry in the IDT</span>
<span class="co">;        [esp    ] the return address</span>
<span class="fu">load_idt:</span>
    <span class="kw">mov</span>     <span class="kw">eax</span>, [<span class="kw">esp</span><span class="dv">+4</span>]    <span class="co">; load the address of the IDT into register eax</span>
    <span class="kw">lidt</span>    <span class="kw">eax</span>             <span class="co">; load the IDT</span>
    <span class="kw">ret</span>                     <span class="co">; return to the calling function</span></code></pre>
<h2 id="programmable-interrupt-controller-pic"><a href="#TOC"><span class="header-section-number">6.5</span> Programmable Interrupt Controller (PIC)</a></h2>
<p>To start using hardware interrupts, you must first configure the Programmable Interrupt Controller (PIC). The PIC makes it possible to map signals from the hardware to interrupts. The reasons for configuring the PIC are:</p>
<ul>
<li>Remap the interrupts. By default, the PIC uses interrupts 0 - 15 for hardware interrupts, which conflicts with the CPU interrupts, so the PIC interrupts must be remapped to another interval.</li>
<li>Select which interrupts to receive. You probably don’t want to receive interrupts from all hardware, since you don’t have code that manages these interrupts anyway.</li>
<li>Set up the correct mode for the PIC.</li>
</ul>
<p>In the beginning, there was only one PIC (PIC 1) and eight interrupts. As more hardware got added in the computer, 8 interrupts were too few. The solution was then to chain on another PIC (PIC 2) on the first PIC (see interrupt 2 on PIC 1).</p>
<p>The hardware interrupts are:</p>
<table>
<thead>
<tr class="header">
<th align="right">PIC 1</th>
<th align="left">Hardware</th>
<th align="right">PIC 2</th>
<th align="left">Hardware</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0</td>
<td align="left">Timer</td>
<td align="right">8</td>
<td align="left">Real Time Clock</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="left">Keyboard</td>
<td align="right">9</td>
<td align="left">General I/O</td>
</tr>
<tr class="odd">
<td align="right">2</td>
<td align="left">PIC 2</td>
<td align="right">10</td>
<td align="left">General I/O</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="left">COM 2</td>
<td align="right">11</td>
<td align="left">General I/O</td>
</tr>
<tr class="odd">
<td align="right">4</td>
<td align="left">COM 1</td>
<td align="right">12</td>
<td align="left">General I/O</td>
</tr>
<tr class="even">
<td align="right">5</td>
<td align="left">LPT 2</td>
<td align="right">13</td>
<td align="left">Coprocessor</td>
</tr>
<tr class="odd">
<td align="right">6</td>
<td align="left">Floppy disk</td>
<td align="right">14</td>
<td align="left">IDE Bus</td>
</tr>
<tr class="even">
<td align="right">7</td>
<td align="left">LPT 1</td>
<td align="right">15</td>
<td align="left">IDE Bus</td>
</tr>
</tbody>
</table>
<p>A great tutorial for configuring the PIC can be found at <span class="citation">[30]</span>.</p>
<p>Every interrupt from the PIC has to be acknowledged, that is, sending a message to the PIC confirming that the interrupt has been handled. If this isn’t done, the PIC won’t generate any more interrupts.</p>
<p>This is done by sending the byte <code>0x20</code> to the PIC that raised the interrupt. Sending the acknowledgement to the PIC that did <em>not</em> raise the interrupt doesn’t do anything. Therefore, implementing a <code>pic_acknowledge</code> function is straightforward:</p>
<pre class="sourceCode c"><code class="sourceCode c">
<span class="ot">#include &quot;io.h&quot;</span>

<span class="ot">#define PIC1_PORT_A 0x20</span>
<span class="ot">#define PIC2_PORT_A 0xA0</span>

<span class="ot">#define PIC_ACK     0x20</span>

<span class="co">/** </span>pic_acknowledge:
 *  Acknowledges an interrupt from either PIC <span class="dv">1</span> or PIC <span class="dv">2</span>.
 <span class="co">*/</span>
<span class="dt">void</span> pic_acknowledge(<span class="dt">void</span>)
{
    outb(PIC1_PORT_A, PIC_ACK);
    outb(PIC2_PORT_A, PIC_ACK);
}</code></pre>
<h2 id="reading-input-from-the-keyboard"><a href="#TOC"><span class="header-section-number">6.6</span> Reading Input from the Keyboard</a></h2>
<p>The keyboard generates interrupt 1 from the PIC, so if you remapped the PIC’s interrupts to start at number 32, the interrupt number for the keyboard will be 33.</p>
<p>The keyboard does not generate ASCII characters, instead it generates scan codes. A scan code represents a button. The scan code representing the just pressed button can be read from the keyboard’s data I/O port:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &quot;io.h&quot;</span>

<span class="ot">#define KBD_DATA_PORT   0x60</span>

<span class="co">/** </span>read_scan_code:
 *  Reads a scan code from the keyboard
 *
 *  <span class="kw">@return</span> The scan code (NOT an ASCII character!)
 <span class="co">*/</span>
<span class="dt">unsigned</span> <span class="dt">char</span> read_scan_code(<span class="dt">void</span>)
{
    <span class="kw">return</span> inb(KBD_DATA_PORT);
}</code></pre>
<p>The next step is to write a function that translates a scan code to the corresponding ASCII character. If you want to map the scan codes to the ASCII characters as is done on an American keyboard, <span class="citation">[31]</span> shows how the scan codes and keyboard buttons correlates.</p>
<p>Remember, since the keyboard interrupt is raised by the PIC, you must call <code>pic_acknowledge</code> at the end of the keyboard interrupt handler!</p>
<h2 id="further-reading-4"><a href="#TOC"><span class="header-section-number">6.7</span> Further Reading</a></h2>
<ul>
<li>The OSDev wiki has a great page on interrupts, <a href="http://wiki.osdev.org/Interrupts"><code class="url">http://wiki.osdev.org/Interrupts</code></a></li>
<li>Chapter 6 of Intel Manual 3a <span class="citation">[28]</span> describes everything there is to know about interrupts.</li>
</ul>
<h1 id="the-road-to-user-mode"><a href="#TOC"><span class="header-section-number">7</span> The Road to User Mode</a></h1>
<p>Now that the kernel boots, prints to screen and reads from keyboard - what do we do? Usually, a kernel is not supposed to do the application logic itself, but leave that for applications. The kernel creates the proper abstractions (for memory, files, devices, etc.) so that application development becomes easier, performs tasks on behalf of applications (system calls), and <a href="#scheduling">schedules processes</a>.</p>
<p>User mode, in contrast with kernel mode, is the environment in which the user’s programs execute. It is less privileged than the kernel, and will prevent badly written user programs from messing with other programs or the kernel. Badly written kernels are free to mess up what they want.</p>
<p>There’s quite a way to go until we get there, but here follows a quick-and-dirty start.</p>
<h2 id="loading-a-program"><a href="#TOC"><span class="header-section-number">7.1</span> Loading a Program</a></h2>
<p>Where do we get the application from? Somehow we need to load the code we want to execute into memory. More feature complete operating system usually have drivers and file system that enables them load the software from a CD-ROM drive, a hard disk or a floppy disk.</p>
<p>Instead of creating all these drivers and file systems, we will use a feature in GRUB called modules to load our program.</p>
<h3 id="grub-modules"><a href="#TOC"><span class="header-section-number">7.1.1</span> GRUB Modules</a></h3>
<p>GRUB can load arbitrary files into memory from the ISO image and these files are usually referred to as modules. To make GRUB load a module, edit the file <code>iso/boot/grub/menu.lst</code> and add the following line at the end of the file</p>
<pre><code>module /modules/program</code></pre>
<p>Now create the folder <code>iso/modules</code></p>
<pre><code>mkdir -p iso/modules</code></pre>
<p>Later in this chapter, the application “program” will be created. We must also update the code that calls <code>kmain</code> to pass information to <code>kmain</code> about where it can find the modules. We also want to tell GRUB that it should align all the modules on page boundaries when loading them (see the chapter about <a href="#paging">“Paging”</a> for details about page alignment).</p>
<p>To instruct GRUB how to load our modules, the “multiboot header”, that is the first bytes of the kernel, must be updated as follows:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; in file `loader.s`</span>


MAGIC_NUMBER    <span class="dt">equ</span> <span class="bn">0x1BADB002</span>      <span class="co">; define the magic number constant</span>
ALIGN_MODULES   <span class="dt">equ</span><span class="bn"> 0x00000001      </span><span class="co">; tell GRUB to align modules</span>

<span class="co">; calculate the checksum (all options + checksum should equal 0)</span>
CHECKSUM        <span class="dt">equ</span> -(MAGIC_NUMBER + ALIGN_MODULES)

<span class="kw">section</span> .text:                      <span class="co">; start of the text (code) section</span>
<span class="kw">align</span> <span class="dv">4</span>                             <span class="co">; the code must be 4 byte aligned</span>
    <span class="dt">dd</span> MAGIC_NUMBER                 <span class="co">; write the magic number</span>
    <span class="dt">dd</span> ALIGN_MODULES                <span class="co">; write the align modules instruction</span>
    <span class="dt">dd</span> CHECKSUM                     <span class="co">; write the checksum</span></code></pre>
<p>GRUB will also store a pointer to a <code>struct</code> in the register <code>ebx</code> that among other things describes at which addresses the modules are loaded. Therefore, you probably want to push <code>ebx</code> on the stack before calling <code>kmain</code> to make into an argument for <code>kmain</code>.</p>
<h2 id="executing-a-program"><a href="#TOC"><span class="header-section-number">7.2</span> Executing a Program</a></h2>
<h3 id="a-very-simple-program"><a href="#TOC"><span class="header-section-number">7.2.1</span> A Very Simple Program</a></h3>
<p>Any program we write at this stage won’t be able to communicate with the outside. Therefore, a very short program that writes a value to a register suffices. Halting Bochs and reading its log should verify that the program has run.</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; set eax to some distinguishable number, to read from the log afterwards</span>
<span class="kw">mov</span> <span class="kw">eax</span>, <span class="bn">0xDEADBEEF</span>

<span class="co">; enter infinite loop, nothing more to do</span>
<span class="co">; $ means &quot;beginning of line&quot;, ie. the same instruction</span>
<span class="kw">jmp</span> <span class="dv">$</span></code></pre>
<h3 id="compiling"><a href="#TOC"><span class="header-section-number">7.2.2</span> Compiling</a></h3>
<p>Since our kernel cannot parse advanced executable formats, we need to compile the code into a flat binary. NASM can do it with the flag <code>-f</code>:</p>
<pre><code>nasm -f bin program.s -o program</code></pre>
<p>This is all we need. You must now move the file <code>program</code> to the folder <code>iso/modules</code>.</p>
<h3 id="finding-the-program-in-memory"><a href="#TOC"><span class="header-section-number">7.2.3</span> Finding the Program in Memory</a></h3>
<p>Before jumping to the program, we must find where it resides in memory. Assuming that the contents of the <code>ebx</code> is passed as an argument to <code>kmain</code>, we can do this entirely from C.</p>
<p>The pointer in <code>ebx</code> points to a multiboot-structure <span class="citation">[17]</span>. Download the <code>multiboot.h</code> file from <a href="http://www.gnu.org/software/grub/manual/multiboot/html_node/multiboot.h.html"><code class="url">http://www.gnu.org/software/grub/manual/multiboot/html_node/multiboot.h.html</code></a>, which describes the structure.</p>
<p>The pointer passed to <code>kmain</code> from the <code>ebx</code> register can now be casted to <code>multiboot_info_t</code> pointer. The address of the first module is now in the field <code>mods_addr</code>, that is</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> kmain(..., <span class="dt">unsigned</span> <span class="dt">int</span> ebx)
{
    multiboot_info_t *mbinfo = (multiboot_info_t *) ebx;
    <span class="dt">unsigned</span> <span class="dt">int</span> address_of_module = mbinfo-&gt;mods_addr;
}</code></pre>
<p>However, before just blindly following the pointer, you should check that the module got loaded correctly. This can be done by checking the <code>flags</code> field of the <code>multiboot_info_t</code> stucture. You should also check the field <code>mods_count</code> to make sure it’s exactly 1. For more details about the multiboot structure, see <span class="citation">[17]</span>.</p>
<h3 id="jumping-to-the-code"><a href="#TOC"><span class="header-section-number">7.2.4</span> Jumping to the Code</a></h3>
<p>What we’d like to do now is just jump to the address of the GRUB-loaded module. Since it is easier to parse the multiboot structure in C, calling the code from C is more convenient, but it can of course be done with <code>jmp</code> (or <code>call</code>) in assembly as well.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">void</span> (*call_module_t)(<span class="dt">void</span>);
<span class="co">/* ... */</span>
call_module_t start_program = (call_module_t) address_of_module;
start_program();
<span class="co">/* we&#39;ll never get here, unless the module code returns */</span></code></pre>
<p>If we start the kernel, wait until it has run and entered the infinite loop in the program, and then halt Bochs, we should see <code>0xDEADBEEF</code> in <code>eax</code> via the Bochs log. We have successfully started a program in our OS!</p>
<h2 id="the-beginning-of-user-mode"><a href="#TOC"><span class="header-section-number">7.3</span> The Beginning of User Mode</a></h2>
<p>The program we’ve written now runs in the same mode as the kernel, we’ve just entered it in a somewhat peculiar way. To enable applications to execute at a different privilege level, we’ll need to do <a href="#segmentation">segmentation</a>, <a href="#paging">paging</a> and <a href="#page-frame-allocation">allocate page frames</a>.</p>
<p>It’s quite a lot of work and technical details to go through, but in a few chapters you’ll have a working user mode programs.</p>
<h1 id="virtual-memory-an-introduction"><a href="#TOC"><span class="header-section-number">8</span> Virtual Memory, an Introduction</a></h1>
<p>Virtual memory is an abstraction of physical memory. The purpose of virtual memory is generally to simplify application development and to let processes address more memory than what is actually physically present. We don’t want applications messing with the kernel or other applications’ memory.</p>
<p>In the x86 architecture, virtual memory can be accomplished in two ways: Segmentation and paging. Paging is by far the most common and versatile technique, and we’ll implement it in chapter 7. Some use of segmentation is still necessary (to allow for code to execute under different privilege levels), so we’ll set up a minimal segmentation structure in the next chapter.</p>
<p>Managing memory is a big part of what an operating system does. <a href="#paging">Paging</a> and <a href="#page-frame-allocation">page frame allocation</a> deals with that.</p>
<p>Segmentation and paging is described in the Intel manual <span class="citation">[28]</span>, chapter 3 and 4.</p>
<h2 id="virtual-memory-through-segmentation"><a href="#TOC"><span class="header-section-number">8.1</span> Virtual Memory Through Segmentation?</a></h2>
<p>You could skip paging entirely and just use segmentation for virtual memory. Each user mode process would get its own segment, with base address and limit properly set up so that no process can see someone else’s memory. A problem with this is that all memory for a process needs to be contiguous. Either we need to know in advance how much memory the program will require (unlikely), or we can move the memory segments to places where they can grow when the limit is reached (expensive, causes fragmentation - can result in “out of memory” even though enough memory is available, but in too small chunks). Paging solves both these problems.</p>
<p>It might be interesting to note that in x86_64 (another CPU architecture), segmentation is almost completely removed.</p>
<h2 id="further-reading-5"><a href="#TOC"><span class="header-section-number">8.2</span> Further Reading</a></h2>
<ul>
<li>LWN.net has an article on virtual memory: <a href="http://lwn.net/Articles/253361/"><code class="url">http://lwn.net/Articles/253361/</code></a></li>
<li>So does Gustavo Duarte: <a href="http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation"><code class="url">http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation</code></a></li>
</ul>
<h1 id="paging"><a href="#TOC"><span class="header-section-number">9</span> Paging</a></h1>
<p>Segmentation translates a logical address into a linear address. Paging translates these linear addresses onto the physical address space, and determines access rights and how the memory should be cached.</p>
<h2 id="why-paging"><a href="#TOC"><span class="header-section-number">9.1</span> Why Paging?</a></h2>
<p>Paging is the most common technique used in x86 to enable virtual memory. Virtual memory means that each process will get the impression that the available memory range is <code>0x00000000</code> - <code>0xFFFFFFFF</code> even though the actual size of the memory is way less. It also means that when a process addresses a byte of memory, they will use a virtual (linear) address instead of physical one. The code in the user process won’t notice any difference (except for execution delays…). The linear address will then get translated to a physical address by the MMU and the page table. If the virtual address isn’t mapped to a physical address, the CPU will raise a page fault interrupt.</p>
<p>Paging is optional, and some operating systems don’t need it. But if we want memory access control (so that we can have processes running in different privilege levels), paging is the neatest way to do it.</p>
<h2 id="paging-in-x86"><a href="#TOC"><span class="header-section-number">9.2</span> Paging in x86</a></h2>
<p>x86 paging (chapter 4 in the Intel manual <span class="citation">[28]</span>) consists of a page directory (PDT) that can contain references to 1024 page tables (PT), each of which can point to 1024 sections of physical memory called page frames (PF); Each page frame is 4096 byte large. In a virtual address (linear address), the highest 10 bits specifies the offset of a page directory entry (PDE) in the current PDT, the next highest 10 bits the offset of a page table entry (PTE) within the page table pointed to by that PDE. The lowest 12 bits in the address is the offset within the page frame to be addressed.</p>
<p>All page directories, page tables and page frames need to be aligned on 4096 byte addresses. This makes it possible to address a PDT, PT or PF with just the highest 20 bits of a 32 bit address, since the lowest 12 need to be zero.</p>
<p>The PDE and PTE structure is very similar to each other: 32 bits (4 bytes), where the highest 20 bits points to a PTE or PF, and the lowest 12 bits control access rights and other configurations. 4 bytes * 1024 equals 4096 bytes, so a page directory and page table both fit in a page frame themselves.</p>
<p>The translation of linear addresses to physical addresses is described in the figure below.</p>
<p>It is also possible to use 4MB pages. A PDE then points directly to a 4MB page frame, which needs to be aligned on a 4MB address boundary. The address translation is almost the same as in the figure, with just the page table step removed. It is possible to mix 4MB and 4KB pages.</p>
<div class="figure">
<img src="images/intel_4_2_linear_address_translation.png" alt="Translating virtual addresses (linear addresses) to physical addresses." /><p class="caption">Translating virtual addresses (linear addresses) to physical addresses.</p>
</div>
<p>The 20 bits pointing to the current PDT is stored in the <code>cr3</code> register. The lower 12 bits of <code>cr3</code> are used configuration.</p>
<p>For more details on the paging structures, see chapter 4 in the Intel manual <span class="citation">[28]</span>. The most interesting bits are U/S, which determine what privilege levels can access this page (PL0 or PL3), and R/W, which makes the memory in the page read-write or read-only.</p>
<h3 id="identity-paging"><a href="#TOC"><span class="header-section-number">9.2.1</span> Identity Paging</a></h3>
<p>The simplest kind of paging is when we map each virtual address onto the same physical address. This can be done at compile time by, for instance, creating a page table where each entry points to its corresponding 4MB frame. In NASM we can do this with macros and commands (<code>%rep</code>, <code>times</code> and <code>dd</code>), or just ordinary assembler instructions.</p>
<h3 id="enabling-paging"><a href="#TOC"><span class="header-section-number">9.2.2</span> Enabling Paging</a></h3>
<p>You enable paging by first writing the address of a page directory to <code>cr3</code> and then setting bit 31 (the PG “paging-enable” bit) of <code>cr0</code> to <code>1</code>. If you want 4MB pages, set the PSE bit (Page Size Extensions, bit 4) of <code>cr4</code>.</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; eax has the address of the page directory</span>
<span class="kw">mov</span> <span class="kw">cr3</span>, <span class="kw">eax</span>

<span class="kw">mov</span> <span class="kw">ebx</span>, <span class="kw">cr4</span>        <span class="co">; read current cr4</span>
<span class="kw">or</span>  <span class="kw">ebx</span><span class="bn">, 0x00000010 </span><span class="co">; set PSE</span>
<span class="kw">mov</span> <span class="kw">cr4</span>, <span class="kw">ebx</span>        <span class="co">; update cr4</span>

<span class="kw">mov</span> <span class="kw">ebx</span>, <span class="kw">cr0</span>        <span class="co">; read current cr0</span>
<span class="kw">or</span>  <span class="kw">ebx</span><span class="bn">, 0x80000000 </span><span class="co">; set PG</span>
<span class="kw">mov</span> <span class="kw">cr0</span>, <span class="kw">ebx</span>        <span class="co">; update cr0</span>

<span class="co">; now paging is enabled</span></code></pre>
<h3 id="a-few-details"><a href="#TOC"><span class="header-section-number">9.2.3</span> A Few Details</a></h3>
<p>It is important to note that all addresses within the page directory, page tables and in <code>cr3</code> needs to be physical addresses to the structures, never virtual. This will be more relevant in later sections where we dynamically update the paging structures, such as in the chapter on <a href="#user-mode">user mode</a>.</p>
<p>An instruction that is useful when an updating a PDT or PT is <code>invlpg</code>. It invalidates the TLB (Translation Lookaside Buffer) for a virtual address. This is only required when changing a PDE or PTE that was previously mapped to something else. If it had previously been marked as not present (bit 0 was set to 0), doing <code>invlpg</code> is unnecessary. Also, changing the value of <code>cr3</code> will cause all entries in the TLB to be invalidated.</p>
<p>Example:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; invalidate any TLB references to virtual address 0</span>
<span class="kw">invlpg</span> [<span class="dv">0</span>]</code></pre>
<h2 id="higher-half-kernel"><a href="#TOC"><span class="header-section-number">9.3</span> Higher-half Kernel</a></h2>
<p>When GRUB loads our kernel into memory, it places the kernel at the physical memory starting at 1MB. With identity mapping, this is also the virtual address of the kernel.</p>
<h3 id="reasons-to-not-identity-map-the-kernel"><a href="#TOC"><span class="header-section-number">9.3.1</span> Reasons to Not Identity Map the Kernel</a></h3>
<p>If the kernel is placed at the beginning of the virtual address space - that is, the virtual address <code>0x00000000</code> to <code>&quot;size of kernel&quot;</code> will map to the location of the kernel in memory - there will be issues when linking the user mode process code. Normally, during linking, the linker assumes that the code will be loaded into the memory position <code>0x00000000</code>. Therefore, when resolving absolute references, <code>0x00000000</code> will be the base address for calculating the exact position. But if the kernel is mapped onto the virtual address space (<code>0x00000000</code>, <code>&quot;size of kernel&quot;</code>), the user mode process cannot be loaded at virtual address <code>0x00000000</code> - it must be placed somewhere else. Therefore, the assumption from the linker that the user mode process is loaded into memory at position <code>0x00000000</code> is wrong. This can be corrected by using a linker script which tells the linker to assume a different starting address, but that is a very cumbersome solution for the users of the operating system.</p>
<p>This also assumes that we want the kernel to be part of the user mode process’ address space. As we will see later, this is a nice feature, since during system calls we don’t have to change any paging structures to get access to the kernels code and data. The kernel pages will of course require privilege level 0 for access, to prevent a user process from reading or writing kernel memory.</p>
<h3 id="the-virtual-address-for-the-kernel"><a href="#TOC"><span class="header-section-number">9.3.2</span> The Virtual Address for the Kernel</a></h3>
<p>Preferably, the kernel should be placed at a very high virtual memory address, for example <code>0xC000000</code> (3GB). The user mode process is not likely to be 3GB large, which is now the only way that it can conflict with the kernel.</p>
<p>If the user mode process is larger than 3GB, some pages will need to be swapped out by the kernel. Swapping pages will not be part of this book.</p>
<h3 id="placing-the-kernel-at-0xc010000"><a href="#TOC"><span class="header-section-number">9.3.3</span> Placing the Kernel at <code>0xC010000</code></a></h3>
<p>Placing the kernel at <code>0xC0100000</code> isn’t hard, but it does require some thought. This is once again a linking problem. When the linker resolves all absolute references in the kernel, it will assume that our kernel is loaded at physical memory location <code>0x00100000</code>, not <code>0x00000000</code>, since we tell it so in our linker script (see the section on <a href="#linking-the-kernel">linking the kernel</a>. However, we want the jumps to be resolved to <code>0xC0100000</code> as base, since otherwise a kernel jump will jump straight into the user mode process code (remember that the user mode process is loaded at virtual memory <code>0x00000000</code> and up).</p>
<p>However, we can’t simply tell the linker to assume that the kernel starts (is loaded) at <code>0xC01000000</code>, since we want it to be loaded at the physical address <code>0x00100000</code>. The reason for having the kernel loaded at 1 MB is because it can’t be loaded at <code>0x00000000</code>, since there is BIOS and GRUB code loaded below 1 MB. We also cannot assume that we can load the kernel at <code>0xC010000</code>, since the machine might not have 3 GB of physical memory.</p>
<p>This can be solved by using both relocation (<code>.=0xC01000000</code>) and the <code>AT</code> instruction in the linker script. Relocation specifies that non-relative memory-references should should use the relocation address as base in address calculations. <code>AT</code> specifies where the kernel should be loaded into memory. Relocation is done at link time by <code>ld</code> <span class="citation">[32]</span>, the load address specified by <code>AT</code> is handled by GRUB when loading the kernel, and is part of the ELF format <span class="citation">[16]</span>.</p>
<h3 id="higher-half-linker-script"><a href="#TOC"><span class="header-section-number">9.3.4</span> Higher-half Linker Script</a></h3>
<p>We can modify the <a href="#linking-the-kernel">first linker script</a> to implement this:</p>
<pre><code>ENTRY(loader)           /* the name of the entry symbol */

. = 0xC0100000          /* the code should be relocated to 3GB + 1MB */

/* align at 4KB and load at 1MB */
.text ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)
{
    *(.text)            /* all text sections from all files */
}

/* align at 4KB and load at 1MB + . */
.rodata ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)
{
    *(.rodata*)         /* all read-only data sections from all files */
}

/* align at 4KB and load at 1MB + . */
.data ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)
{
    *(.data)            /* all data sections from all files */
}

/* align at 4KB and load at 1MB + . */
.bss ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)
{
    *(COMMON)           /* all COMMON sections from all files */
    *(.bss)             /* all bss sections from all files */
}</code></pre>
<h3 id="entering-the-higher-half"><a href="#TOC"><span class="header-section-number">9.3.5</span> Entering the Higher Half</a></h3>
<p>When GRUB jumps to the kernel code, there is no paging table. Therefore, all references to <code>0xC0100000 + X</code> won’t be mapped to the correct physical address, and will therefore cause a general protection exception (GPE) at the very best, otherwise (if the user has more than 3 GB of memory) the OS will just crash.</p>
<p>Therefore, assembly code that doesn’t use absolute jumps must be used to set up the page table, add one entry for the first 4 MB of the virtual address space that maps to the first 4 MB of the physical memory and finally an entry for <code>0xC0100000</code> that maps to <code>0x0010000</code>. If we skip the identity mapping for the first 4 MB, the CPU would generate a page fault immediately after paging was enabled when trying to fetch the next instruction from memory. After the table has been created, an indirect jump can be done to a label, to make <code>eip</code> point to a high address:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; assembly code executing at around 0x00100000</span>
<span class="co">; enable paging for both actual location of kernel</span>
<span class="co">; and its higher-half virtual location</span>

<span class="kw">lea</span> <span class="kw">ebx</span>, [higher_half] <span class="co">; load the address of the label in ebx</span>
<span class="kw">jmp</span> <span class="kw">ebx</span>                <span class="co">; jump to the label</span>

<span class="fu">higher_half:</span>
    <span class="co">; code here executes in the higher half kernel</span>
    <span class="co">; eip is larger than 0xC0000000</span>
    <span class="co">; can continue kernel initialisation, calling C code, etc.</span></code></pre>
<p>Now <code>eip</code> will point to a memory location somewhere right after <code>0xC0100000</code> - all the code can now execute as if it were at <code>0xC0100000</code>, the higher-half. The entry mapping the first 4MB of virtual memory to the first 4MB of physical can be removed from the page table, and its corresponding entry in the TLB invalidated with <code>invlpg [0]</code>.</p>
<h3 id="running-in-the-higher-half"><a href="#TOC"><span class="header-section-number">9.3.6</span> Running in the Higher Half</a></h3>
<p>There are a few details we must deal with when using a higher-half kernel. We must now take care when using memory mapped I/O that uses specific memory locations. For example, the frame buffer is located at <code>0x000B8000</code>, but since there is no entry in the page table for the address <code>0x000B8000</code> any longer, the address <code>0xC00B8000</code> must be used, since the virtual address <code>0xC0000000</code> maps to the physical address <code>0x00000000</code>.</p>
<p>Any explicit references to addresses within the multiboot structure needs to be changed to reflect the new virtual addresses as well.</p>
<p>Mapping entire 4 MB pages for the kernel is very simple, but wastes quite some memory (unless you have a really big kernel). Creating a higher-half kernel mapped in as 4KB pages is doable, but somewhat trickier. The page directory and one page table can be in <code>.data</code> (assuming your kernel is smaller than 4 MB), but you need to configure the mappings at runtime. The size of the kernel can be determined by exporting labels from the linker script <span class="citation">[32]</span>, which we’ll need to do later anyway when writing the <a href="#how-much-memory-is-there">page frame allocator</a>.</p>
<h2 id="virtual-memory-through-paging"><a href="#TOC"><span class="header-section-number">9.4</span> Virtual Memory Through Paging</a></h2>
<p>Paging enables two things that are good for virtual memory. First, it allows for fine-grained access control to memory. You can mark pages as read-only, read-write, only for PL0 etc. Second, it creates the illusion of contiguous memory. User mode processes, and the kernel, can access memory as if it were contiguous, and the contiguous memory can be extended without the need to move stuff around. Also, we can allow the user mode programs to access all memory below 3GB, but unless they actually use it, we don’t have to assign page frames to the pages. This allows processes to have code located near <code>0x00000000</code> and the stack at just below <code>0xC0000000</code>, and still not require more than two actual pages.</p>
<h2 id="further-reading-6"><a href="#TOC"><span class="header-section-number">9.5</span> Further Reading</a></h2>
<ul>
<li>Chapter 4 (and to some extent chapter 3) of the Intel manual <span class="citation">[28]</span> are your definitive sources for the details about paging.</li>
<li>Wikipedia has an article on paging: <a href="http://en.wikipedia.org/wiki/Paging"><code class="url">http://en.wikipedia.org/wiki/Paging</code></a></li>
<li>The OSDev wiki has a page on paging: <a href="http://wiki.osdev.org/Paging"><code class="url">http://wiki.osdev.org/Paging</code></a> and a tutorial for making a higher-half kernel: <a href="http://wiki.osdev.org/Higher_Half_bare_bones"><code class="url">http://wiki.osdev.org/Higher_Half_bare_bones</code></a></li>
<li>Gustavo Duarte’s article on how a kernel manages memory is well worth a read: <a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory"><code class="url">http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory</code></a></li>
<li>Details on the linker command language can be found in <span class="citation">[32]</span>.</li>
<li>More details on the ELF format can be found in this pdf: <a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf"><code class="url">http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf</code></a></li>
</ul>
<h1 id="page-frame-allocation"><a href="#TOC"><span class="header-section-number">10</span> Page Frame Allocation</a></h1>
<p>Now that we have virtual memory with paging set up, we need to somehow allocate some of the available memory to use for the applications we want to run. How do we know what memory is free? That is the role of a page frame allocator.</p>
<h2 id="managing-available-memory"><a href="#TOC"><span class="header-section-number">10.1</span> Managing Available Memory</a></h2>
<h3 id="how-much-memory-is-there"><a href="#TOC"><span class="header-section-number">10.1.1</span> How Much Memory is There?</a></h3>
<p>First we need to know how much memory the computer we’re running on has. The easiest way to do this is to read it from the multiboot <span class="citation">[17]</span> structure sent to us by GRUB. GRUB collects the information we need about the memory - what is reserved, I/O mapped, read-only etc. We must make sure that we don’t mark the part of memory used by the kernel as free. One way to do this is to export labels at the beginning and end of the kernel binary from the linker script.</p>
<p>The updated linker script:</p>
<pre><code>ENTRY(loader)           /* the name of the entry symbol */

. = 0xC0100000          /* the code should be relocated to 3 GB + 1 MB */

/* these labels get exported to the code files */
kernel_virtual_start = .;
kernel_physical_start = . - 0xC0000000;

/* align at 4 KB and load at 1 MB */
.text ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)
{
    *(.text)            /* all text sections from all files */
}

/* align at 4 KB and load at 1 MB + . */
.rodata ALIGN (0x1000) : AT(ADDR(.rodata)-0xC0000000)
{
    *(.rodata*)         /* all read-only data sections from all files */
}

/* align at 4 KB and load at 1 MB + . */
.data ALIGN (0x1000) : AT(ADDR(.data)-0xC0000000)
{
    *(.data)            /* all data sections from all files */
}

/* align at 4 KB and load at 1 MB + . */
.bss ALIGN (0x1000) : AT(ADDR(.bss)-0xC0000000)
{
    *(COMMON)           /* all COMMON sections from all files */
    *(.bss)             /* all bss sections from all files */
}

kernel_virtual_end = .;
kernel_physical_end = . - 0xC0000000;</code></pre>
<p>Assembly code can read these labels directly, and perhaps push them onto the stack so we can use them from C:</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">extern</span> kernel_virtual_start
<span class="kw">extern</span> kernel_virtual_end
<span class="kw">extern</span> kernel_physical_start
<span class="kw">extern</span> kernel_physical_end

<span class="co">; ...</span>

<span class="kw">push</span> kernel_physical_end
<span class="kw">push</span> kernel_physical_start
<span class="kw">push</span> kernel_virtual_end
<span class="kw">push</span> kernel_virtual_start

<span class="kw">call</span> kmain</code></pre>
<p>This way we get the labels as arguments to <code>kmain</code>. If you want to use C instead of assembly, one way to do it is to declare the label as a function and take the address of the function:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> kernel_virtual_start(<span class="dt">void</span>);

<span class="co">/* ... */</span>

<span class="dt">unsigned</span> <span class="dt">int</span> vaddr = (<span class="dt">unsigned</span> <span class="dt">int</span>) &amp;kernel_virtual_start;</code></pre>
<p>If you use GRUB modules you also need to make sure the memory they use is marked as “in use” as well.</p>
<p>Note that not all available memory needs to be contiguous. In the first 1MB there are several I/O-mapped memory sections, as well as memory used by GRUB and the BIOS. Other parts of the memory might be similarly unavailable.</p>
<p>It’s convenient to divide the memory sections into complete page frames, as we can’t map part of pages into memory.</p>
<h3 id="managing-available-memory-1"><a href="#TOC"><span class="header-section-number">10.1.2</span> Managing Available Memory</a></h3>
<p>How do we know which page frames are in use? The page frame allocator needs to keep track of which are free and which aren’t. There are several ways to do this: Bitmaps, linked lists, trees, the Buddy System (used by Linux) etc. See <a href="http://wiki.osdev.org/Page_Frame_Allocation"><code class="url">http://wiki.osdev.org/Page_Frame_Allocation</code></a> for more details.</p>
<p>Bitmaps are quite easy to implement. One bit for each page frame, and dedicate one (or more) page frames to store the bitmap. But other designs might be better and/or more fun.</p>
<h2 id="how-can-we-access-a-page-frame"><a href="#TOC"><span class="header-section-number">10.2</span> How Can We Access a Page Frame?</a></h2>
<p>When we use our page frame allocator to allocate page frames, it gives us the physical start address of the page frame. This page frame is not mapped in - no page table points to the frame. (If we mapped an entire 4MB chunk for the kernel, and the page frame lies somewhere in there, it will be mapped in.) How can we read and write data to the frame?</p>
<p>We need to map the page frame into virtual memory, by updating the PDT and/or PT used by the kernel. What if all available page tables are full? Then we can’t map the page frame into memory, because we’d need a new page table - which takes up an entire page frame - and to write to this page frame we’d need to map it in…</p>
<p>One solution is to reserve part of the first page table used by the kernel (or some other higher-half page table) for temporarily mapping in page frames so that we can access to them. If the kernel is mapped in at <code>0xC0000000</code> (page directory entry with index 768), and we’ve used 4KB page frames, the kernel has at least one page table. If we assume, or limit us to, a kernel of size at most 4MB minus 4KB, we can dedicate the last entry (entry 1023) of this page table for temporary mappings. The virtual address of pages mapped in like this will be:</p>
<pre><code>(768 &lt;&lt; 22) | (1023 &lt;&lt; 12) | 0x000 = 0xC03FF000</code></pre>
<p>After we’ve temporarily mapped in the page frame we want to use as a page table, and set it up to map in our first page frame, we can add it to the paging directory, and remove the temporary mapping. (This leads to the quite nice property that no paging tables need to be mapped in unless we need to edit them).</p>
<h2 id="a-kernel-heap"><a href="#TOC"><span class="header-section-number">10.3</span> A Kernel Heap</a></h2>
<p>So far we’ve been able to work with only fixed-size data, or directly with raw memory. Now that we have a page frame allocator we can implement <code>malloc</code> and <code>free</code> to use in the kernel.</p>
<p>Kernighan and Ritchie have an example implementation in <span class="citation">[6]</span> that we can draw inspiration from. The only real modifications we need to do is to remove calls to <code>sbrk</code>/<code>brk</code>, and directly ask the page frame allocator for the page frames, and the paging system to map them in.</p>
<p>This can be done quick and dirty. A real implementation should also give back page frames to the page frame allocator on <code>free</code>, whenever sufficiently large blocks are freed.</p>
<h2 id="further-reading-7"><a href="#TOC"><span class="header-section-number">10.4</span> Further reading</a></h2>
<ul>
<li>The OSDev wiki page on page frame allocation: <a href="http://wiki.osdev.org/Page_Frame_Allocation"><code class="url">http://wiki.osdev.org/Page_Frame_Allocation</code></a></li>
</ul>
<h1 id="user-mode"><a href="#TOC"><span class="header-section-number">11</span> User Mode</a></h1>
<p>User mode is now almost within our reach. There’s just a few more steps required. They don’t seem too much work on paper, but they can take quite a few hours to get right in code and design.</p>
<h2 id="segments-for-user-mode"><a href="#TOC"><span class="header-section-number">11.1</span> Segments for User Mode</a></h2>
<p>To enable user mode we need to add two more segments to the GDT. They are very similar to the kernel segments we added when we <a href="#the-global-descriptor-table-gdt">set up the GDT</a> in the <a href="#segmentation">chapter about segmentation</a>.</p>
<table>
<caption>The segment descriptors needed for user mode.</caption>
<thead>
<tr class="header">
<th align="right">Index</th>
<th align="right">Offset</th>
<th align="left">Name</th>
<th align="left">Address range</th>
<th align="left">Type</th>
<th align="left">DPL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">3</td>
<td align="right"><code>0x18</code></td>
<td align="left">user code segment</td>
<td align="left"><code>0x00000000 - 0xFFFFFFFF</code></td>
<td align="left">RX</td>
<td align="left">PL3</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right"><code>0x20</code></td>
<td align="left">user data segment</td>
<td align="left"><code>0x00000000 - 0xFFFFFFFF</code></td>
<td align="left">RW</td>
<td align="left">PL3</td>
</tr>
</tbody>
</table>
<p>The difference is the DPL, which now allows code to execute in PL3. The segments can still be used to address the entire address space, so just using these segments for user mode code will not protect the kernel. For that we need paging.</p>
<h2 id="setting-up-for-user-mode"><a href="#TOC"><span class="header-section-number">11.2</span> Setting Up For User Mode</a></h2>
<p>There are a few things every user mode process needs:</p>
<ul>
<li><p>Page frames for code, data and stack. For now we can just allocate one page frame for the stack, and enough page frames to fit the code and fixed-size data.</p></li>
<li><p>We need to copy the binary from the GRUB modules to the frames used for code.</p></li>
<li><p>We need a page directory and page tables to map these page frames into memory. At least two page tables are needed, because the code and data should be mapped in at <code>0x00000000</code> and increasing, and the stack should start just below the kernel, at <code>0xBFFFFFFB</code>, growing to lower addresses. Make sure the U/S flag is set to allow PL3 access.</p></li>
</ul>
<p>It might be convenient to store these in a struct of some kind, dynamically allocated with the kernel <code>malloc</code>.</p>
<h2 id="entering-user-mode"><a href="#TOC"><span class="header-section-number">11.3</span> Entering User Mode</a></h2>
<p>The only way to execute code with a lower privilege level than the current privilege level (CPL) is to execute an <code>iret</code> or <code>lret</code> instruction - interrupt return or long return, respectively.</p>
<p>To enter user mode, we set up the stack as if the processor had raised an inter-level interrupt. The stack should look like this:</p>
<pre><code>[esp + 16]  ss      ; the stack segment selector we want for user mode
[esp + 12]  esp     ; the user mode stack pointer
[esp +  8]  eflags  ; the control flags we want to use in user mode
[esp +  4]  cs      ; the code segment selector
[esp +  0]  eip     ; the instruction pointer of user mode code to execute</code></pre>
<p>(source: The Intel manual <span class="citation">[28]</span>, section 6.2.1, figure 6-4)</p>
<p><code>iret</code> will then read these values from the stack and fill in the corresponding registers. Before we execute <code>iret</code> we need to change to the page directory we setup for the user mode process. Important to remember here is that, to continue executing kernel code after we’ve switched PDT, the kernel needs to be mapped in. One way to accomplish this is to have a “kernel PDT”, which maps in all kernel data at <code>0xC0000000</code> and above, and merge it with the user PDT (which only maps below <code>0xC0000000</code>) when we do the switch. Also, remember that we need to use the physical address for the page directory when we set <code>cr3</code>.</p>
<p><code>eflags</code> is a register for a set of different flags, specified in section 2.3 of the Intel manual <span class="citation">[28]</span>. Most important for us is the interrupt enable (IF) flag. When in PL3 we aren’t allowed to use <code>sti</code> like we’d normally do to enable interrupts. If interrupts are disabled when we enter user mode, we can’t enable them when we get there. When we use <code>iret</code> to enter user mode it will set <code>eflags</code> for us, so setting the IF flag in the <code>eflags</code> entry on the stack will enable interrupts in user mode.</p>
<p>For now, we should have interrupts disabled, as it requires a little more twiddling to get inter-privilege level interrupts to work properly. See the section on <a href="#system-calls">system calls</a>.</p>
<p>The <code>eip</code> should point to the entry point for the user code - <code>0x00000000</code> in our case. <code>esp</code> should be where the stack should start - <code>0xBFFFFFFB</code>.</p>
<p><code>cs</code> and <code>ss</code> should be the segment selectors for the user code and user data segments, respectively. As we saw in the <a href="#creating-and-loading-the-gdt">segmentation chapter</a>, the lowest two bits of a segment selector is the RPL - the Requested Privilege Level. When we execute the <code>iret</code> we want to enter PL3, so the RPL of <code>cs</code> and <code>ss</code> should be 3.</p>
<pre><code>cs = 0x18 | 0x3
ss = 0x20 | 0x3</code></pre>
<p><code>ds</code> - and the other data segment registers - should be set to the same segment selector as <code>ss</code>. They can be set the ordinary way, with <code>mov</code>.</p>
<p>Now we are ready to execute <code>iret</code>. If everything has been set up right, we now have a kernel that can enter user mode. Yay!</p>
<h2 id="using-c-for-user-mode-programs"><a href="#TOC"><span class="header-section-number">11.4</span> Using C for User Mode Programs</a></h2>
<p>The kernel is compiled as an ELF <span class="citation">[16]</span> binary, which is a format that allows for more complex and convenient layouts and functionality than a plain flat binary. The reason we can use ELF for the kernel is that GRUB knows how to parse the ELF structure.</p>
<p>If we implement an ELF parser, we can compile the user mode programs into ELF binaries as well. We leave this as an exercise for the reader.</p>
<p>One thing we can do to make it easier to develop user mode programs is to allow them to be written in C but still compile them to flat binaries. In C the layout of the generated code is more unpredictable and the entry point (<code>main()</code>) might not be at offset 0.</p>
<p>One way to work around this is to add a few assembler lines placed at offset 0 which calls <code>main()</code>.</p>
<p>Assembler code (<code>start.s</code>):</p>
<pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">extern</span> main

<span class="kw">section</span> .text
    <span class="co">; push argv</span>
    <span class="co">; push argc</span>
    <span class="kw">call</span> main
    <span class="co">; main has returned, eax is return value</span>
    <span class="kw">jmp</span>  <span class="dv">$</span>    <span class="co">; loop forever</span></code></pre>
<p>Linker script (<code>link.ld</code>) to place <code>start.o</code> first:</p>
<pre><code>OUTPUT_FORMAT(&quot;binary&quot;)    /* output flat binary */

SECTIONS
{
    . = 0;                 /* relocate to address 0 */

    .text ALIGN(4):
    {
        start.o(.text)     /* include the .text section of start.o */
        *(.text)           /* include all other .text sections */
    }

    .data ALIGN(4):
    {
        *(.data)
    }

    .rodata ALIGN(4):
    {
        *(.rodata*)
    }
}</code></pre>
<p>Note: <code>*(.text)</code> will not include the <code>.text</code> section of <code>start.o</code> again. See <span class="citation">[32]</span> for more details.</p>
<p>With this script we can write programs in C or assembler (or any other language that compiles to object files linkable with <code>ld</code>), and it is easy to load and map in for the kernel. (<code>.rodata</code> will be mapped in as writeable, though.)</p>
<p>When we compile user programs we want the usual <code>CFLAGS</code>:</p>
<pre><code>-m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector -nostartfiles
-nodefaultlibs</code></pre>
<p>And these <code>LDFLAGS</code>:</p>
<pre><code>-T link.ld -melf_i386  # emulate 32 bits ELF, the binary output is specified in the linker script</code></pre>
<h3 id="a-c-library"><a href="#TOC"><span class="header-section-number">11.4.1</span> A C Library</a></h3>
<p>It might now be interesting to start thinking about writing a short libc for your programs. Some of the functionality require <a href="#system-calls">system calls</a> to work, but some, such as the <code>string.h</code> functions, does not.</p>
<h2 id="further-reading-8"><a href="#TOC"><span class="header-section-number">11.5</span> Further Reading</a></h2>
<ul>
<li>Gustavo Duarte has an article on privilege levels: <a href="http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection"><code class="url">http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection</code></a></li>
</ul>
<h1 id="file-systems"><a href="#TOC"><span class="header-section-number">12</span> File Systems</a></h1>
<p>We are not required to have file systems in our operating system, but it is quite convenient, and it often plays a central part in many operations of several existing OS’s, especially UNIX-like systems. Before we start the process of supporting multiple processes and system calls, we might want to consider implementing a simple file system.</p>
<h2 id="why-a-file-system"><a href="#TOC"><span class="header-section-number">12.1</span> Why a File System?</a></h2>
<p>How do we specify what programs to run in our OS? Which is the first program to run? How do programs output data? Read input?</p>
<p>In UNIX-like systems, with their almost-everything-is-a-file convention, these problems are solved by the file systems. It might also be interesting to read a bit about the Plan 9 project, which takes this idea one step further (See <a href="#further-reading-6">further reading</a> below).</p>
<h2 id="a-simple-file-system"><a href="#TOC"><span class="header-section-number">12.2</span> A Simple File System</a></h2>
<p>The most simple file system possible might be what we already have - one “file”, existing only in RAM, loaded by GRUB before the kernel starts. When our kernel and operating system grows, this is probably too limiting.</p>
<p>A next step could be to add structure to this GRUB-loaded module. With a utility program - perhaps called <code>mkfs</code> - which we run at build time, we can create our file system in this file.</p>
<p><code>mkfs</code> can traverse a directory on our host system and add all subdirectories and files as part of our target file system. Each object in the file system (directory or file) can consist of a header and a body, where the body of a file is the actual file and the body of a directory is a list of entries - names and “addresses” of other files and directories.</p>
<p>Each object in this file system will become contiguous, so they will be easy to read from our kernel. All objects will also have a fixed size (except for the last one, which can grow); it might be difficult to add new or modify existing files. We can make the file system read-only.</p>
<p><code>mmap</code> is a handy system call that makes writing the “file system-in-a-file” easier.</p>
<h2 id="inodes-and-writable-file-systems"><a href="#TOC"><span class="header-section-number">12.3</span> Inodes and Writable File Systems</a></h2>
<p>When we decide that we want a more complex - and realistic - file system, we might want to look into the concept of inodes. See <a href="#further-reading-6">further reading</a>.</p>
<h2 id="a-virtual-file-system-and-devfs"><a href="#TOC"><span class="header-section-number">12.4</span> A Virtual File System and devfs</a></h2>
<p>What abstraction should we use for reading and writing to devices such as the screen and the keyboard?</p>
<p>With a virtual file system (VFS) we create an abstraction on top of any real file systems we might have. The VFS mainly supplies the path system and file hierarchy, and delegates operations on files to the underlying file systems. The original paper on VFS is succinct, concrete, and well worth a read. See <a href="#further-reading-6">further reading</a>.</p>
<p>With a VFS we can mount a special file system on <code>/dev</code>, which handles all devices such as keyboards and the screen. Or we can take the traditional UNIX approach, with major/minor device numbers and <code>mknod</code> to create special files for our devices.</p>
<h2 id="further-reading-9"><a href="#TOC"><span class="header-section-number">12.5</span> Further Reading</a></h2>
<ul>
<li>The ideas behind the Plan 9 operating systems is worth taking a look at: <a href="http://plan9.bell-labs.com/plan9/index.html"><code class="url">http://plan9.bell-labs.com/plan9/index.html</code></a></li>
<li>Wikipedia’s page on inodes: <a href="http://en.wikipedia.org/wiki/Inode"><code class="url">http://en.wikipedia.org/wiki/Inode</code></a> and the inode pointer structure: <a href="http://en.wikipedia.org/wiki/Inode_pointer_structure"><code class="url">http://en.wikipedia.org/wiki/Inode_pointer_structure</code></a>.</li>
<li>The original paper on the concept of vnodes and a virtual file system is quite interesting: <a href="http://www.arl.wustl.edu/~fredk/Courses/cs523/fall01/Papers/kleiman86vnodes.pdf"><code class="url">http://www.arl.wustl.edu/~fredk/Courses/cs523/fall01/Papers/kleiman86vnodes.pdf</code></a></li>
<li>Poul-Henning Kamp discusses the idea of a special file system for <code>/dev</code> in <a href="http://static.usenix.org/publications/library/proceedings/bsdcon02/full_papers/kamp/kamp_html/index.html"><code class="url">http://static.usenix.org/publications/library/proceedings/bsdcon02/full_papers/kamp/kamp_html/index.html</code></a></li>
</ul>
<h1 id="system-calls"><a href="#TOC"><span class="header-section-number">13</span> System Calls</a></h1>
<h2 id="what-is-a-system-call"><a href="#TOC"><span class="header-section-number">13.1</span> What is a System Call?</a></h2>
<p>System calls (syscalls) is the way for user-mode applications to interact with the kernel - to ask for resources, request operations to be performed, etc. The syscall API is the part of the kernel most exposed to the users, so its design requires some thought.</p>
<h2 id="designing-system-calls"><a href="#TOC"><span class="header-section-number">13.2</span> Designing System Calls</a></h2>
<p>It is up to us, the kernel developers, to design the system calls that applications developer can use. We can draw inspiration from the POSIX standards or, if they seem a bit too much, just look at the ones for Linux, and pick and choose. See <a href="#further-reading-7">further reading</a> below.</p>
<h2 id="implementing-system-calls"><a href="#TOC"><span class="header-section-number">13.3</span> Implementing System Calls</a></h2>
<p>Syscalls are traditionally implemented with software interrupts. The user applications puts the appropriate values in registers or on the stack and then initiates a pre-defined interrupt which transfers execution to the kernel. The interrupt number used is kernel-dependent. Linux uses <code>0x80</code>.</p>
<p>With “newer” versions of x86, Intel and AMD has implemented two different ways to initiate syscalls that are faster than interrupts - <code>syscall</code>/<code>sysenter</code> and <code>sysret</code>/<code>sysexit</code>, respectively.</p>
<p>When syscalls are executed, the current privilege level is typically changed from PL3 to PL0. To allow this, the DPL of the entry in the IDT for the syscall interrupt needs to allow PL3 access.</p>
<p>Whenever inter-privilege level interrupts occurs, the processor pushes a few important registers on the stack - the same ones we used to enter user mode <a href="#user-mode">before</a>, see figure 6-4, section 6.12.1, in the Intel manual <span class="citation">[28]</span>. But what stack is used? The same section in <span class="citation">[28]</span> specifies that if the interrupt leads to code executing at numerically lower privilege levels, a stack switch occurs. The values for the new <code>ss</code> and <code>esp</code> is taken from the current Task State Segment (TSS). The TSS structure is specified in figure 7-2, section 7.2.1 of <span class="citation">[28]</span>.</p>
<p>To enable syscalls we need to setup a TSS for our currently running programs before we enter user mode. Setting it up can easily be done in C, where we enter the <code>ss</code> and <code>esp</code> values. To load it into the processor, we need to set up a new TSS descriptor in our GDT. The structure of this descriptor is described in section 7.2.2 in <span class="citation">[28]</span>.</p>
<p>We specify the current TSS segment selector by loading it into the <code>tr</code> register with <code>ltr</code>. If the TSS segment descriptor has index 5, and thus offset <code>5 * 8 = 40 = 0x28</code>, this is what we should load into <code>tr</code>.</p>
<p>When we <a href="#entering-user-mode">entered user mode before</a> we disabled interrupts when executing in PL3. For syscalls via interrupts to work, we need to enable interrupts. We enter user mode by using the <code>iret</code> instruction, and this loads the <code>eflags</code> register from the stack for us. Setting the IF flag bit in the <code>eflags</code> on the stack will make <code>iret</code> enable interrupts for us.</p>
<h2 id="further-reading-10"><a href="#TOC"><span class="header-section-number">13.4</span> Further Reading</a></h2>
<ul>
<li>The Wikipedia page on POSIX, with links to the specifications: <a href="http://en.wikipedia.org/wiki/POSIX"><code class="url">http://en.wikipedia.org/wiki/POSIX</code></a></li>
<li>A list of syscalls used in linux: <a href="http://bluemaster.iu.hio.no/edu/dark/lin-asm/syscalls.html"><code class="url">http://bluemaster.iu.hio.no/edu/dark/lin-asm/syscalls.html</code></a></li>
<li>The Wikipedia page on system calls: <a href="http://en.wikipedia.org/wiki/System_call"><code class="url">http://en.wikipedia.org/wiki/System_call</code></a></li>
<li>The Intel manual <span class="citation">[28]</span> sections on interrupts (chapter 6) and TSS’ (chapter 7) are where you get all the details you need.</li>
</ul>
<h1 id="scheduling"><a href="#TOC"><span class="header-section-number">14</span> Scheduling</a></h1>
<p>How do you make multiple processes appear to run at the same time? Today, this question has two answers:</p>
<ul>
<li>With the availability of multi-core processors, or on system with multiple processors, two processes can actually run at the same time by running two processes on different cores or processors</li>
<li>Fake it. That is, switch rapidly (faster than a human can experience) between the processes. At any given moment, there is only process executing, but the rapid switching gives the impression that they are running “at the same time”.</li>
</ul>
<p>Since the operating system created in this book does not support multi-core processors or multiple processors, our only option is to fake it. The part of the operating system responsible for rapidly switching between the processes is called the <em>scheduler</em>.</p>
<h2 id="creating-new-processes"><a href="#TOC"><span class="header-section-number">14.1</span> Creating New Processes</a></h2>
<p>Creating new processes is usually done with two different system calls: <code>fork</code> and <code>exec</code>. <code>fork</code> creates an exact copy of the currently running process, while <code>exec</code> replaces the current process with another, often specified by a path to the programs location in the file system. Of these two, we recommend that you start implementing <code>exec</code>, since this system call will do almost exactly the same steps as described in <a href="#setting-up-for-user-mode">“Setting up for user mode”</a>.</p>
<h2 id="cooperative-scheduling-with-yielding"><a href="#TOC"><span class="header-section-number">14.2</span> Cooperative Scheduling with Yielding</a></h2>
<p>The easiest way to achieve the rapid switching between processes is if the processes themselves are responsible for the switching. That is, the processes runs for a while and then tells the OS (via a syscall) that it can now switch to another process. Giving up the control of CPU to another process is called <em>yielding</em> and when the processes themselves are responsible for the scheduling, it’s called <em>cooperative scheduling</em>, since all the processes must cooperate with each other.</p>
<p>When a process yields, the process entire state must be saved (all the registers), preferably in the kernel heap in a structure that represents a process. When changing to a new process, all the registers must be updated with the saved values.</p>
<p>In order to implement scheduling, you must keep a list of which processes are running. The system call “yield” should then run the next process in the list and puts the current one last (other schemes are possible, but this is a simple one). The transfer of control to the new process is done via <code>iret</code> in exactly the same way as explained in the section <a href="#entering-user-mode">“Entering user mode”</a>.</p>
<p>We <strong>strongly</strong> recommend that you start to implement support for multiple processes by implementing cooperative scheduling. We further recommend that you have a working solution for both <code>exec</code>, <code>fork</code> and <code>yield</code> before implementing preemptive scheduling. The reason for this is because it is much easier to debug cooperative scheduling, since it is deterministic.</p>
<h2 id="preemptive-scheduling-with-the-timer"><a href="#TOC"><span class="header-section-number">14.3</span> Preemptive Scheduling with the Timer</a></h2>
<p>Instead of letting the processes themselves manage when it is time to change to another process, the OS can switch processes automatically after a short period of time. The OS can set up the programmable interval timer (PIT) to raise an interrupt after a short period of time, for example 20 ms. In the interrupt handler for the PIT interrupt, the OS will change the running process to a new one. This way, the processes themselves don’t need to worry about scheduling.</p>
<h3 id="programmable-interval-timer"><a href="#TOC"><span class="header-section-number">14.3.1</span> Programmable Interval Timer</a></h3>
<p>To be able to do preemptive scheduling, the programmable interval timer (PIT) must be first be configured to raise interrupts every <em>x</em> milliseconds, where <em>x</em> should be configurable.</p>
<p>The configuration of the PIT is very similar to the configuration of other hardware devices, you send a byte to an I/O port. The command port of the PIT is located at <code>0x43</code>. To read about all the configuration options, see <span class="citation">[33]</span>. We use the following options:</p>
<ul>
<li>Raise interrupts (use channel 0)</li>
<li>Send the divider as low byte then high byte (see next section for an explanation)</li>
<li>Use a square wave</li>
<li>Use binary mode</li>
</ul>
<p>This results in the configuration byte <code>00110110</code>.</p>
<p>Setting the interval for how often interrupts are to be raised is done via a <em>divider</em>, the same way as for the serial port. Instead of sending the PIT a value (e.g. in milliseconds) that says how often an interrupt should be raised, you send a <em>divider</em>. The PIT operates at 1193182 Hz as default. To change this, you send a divider, for example 10. The PIT will then run at <code>1193182 / 10 = 119318</code> Hz. The divider can only be 16 bits, so it only possible to configure the timers frequency between 1193182 Hz and <code>1193182 / 65535 = 18.2</code> Hz. We recommend that you create a function that takes an interval in milliseconds and converts it to the correct divider.</p>
<p>The divider is then sent to channel 0 data I/O port of the PIT, but since you can only send 1 byte at a time, you must first send the lowest 8 bits, then the highest 8 bits of the divider. The channel 0 data I/O port is at <code>0x40</code>. See <span class="citation">[33]</span> for more details.</p>
<h3 id="separate-kernel-stacks-for-processes"><a href="#TOC"><span class="header-section-number">14.3.2</span> Separate Kernel Stacks for Processes</a></h3>
<p>If all processes uses the same kernel stack (the stack exposed by the TSS), there will be trouble if a process is interrupted while still in kernel mode. The process that is being switched to will now use the same kernel stack, and will then overwrite what the previous have written on the stack (remember that TSS data structure points to the <em>beginning</em> of the stack).</p>
<p>To solve this problem, every process should have it’s own kernel stack, the same way that each process have their own user mode stack. When switching process, the TSS must then be updated to point to the new process kernel stack.</p>
<h3 id="difficulties-with-preemptive-scheduling"><a href="#TOC"><span class="header-section-number">14.3.3</span> Difficulties with Preemptive Scheduling</a></h3>
<p>When using preemptive scheduling, one problem arises that doesn’t exist with cooperative scheduling. With cooperative scheduling, every time a process yields, it must be in user mode (privilege level 3), since yield is a system call. With preemptive scheduling, the processes can be interrupted in either user mode or kernel mode (privilege level 0), since the process itself does not control when it gets interrupted.</p>
<p>Interrupting a process in kernel mode is a little bit different than interrupting a process in user mode, due to the way the CPU sets up the stack at interrupts. If a privilege level change occurs (the process was interrupted in user mode), then the CPU will push the value of the process <code>ss</code> and <code>esp</code> register on the stack. If no privilege level change occurs (the process was interrupted in kernel mode), then the CPU won’t push the <code>esp</code> register on the stack. Furthermore, if there is no privilege level change, the CPU won’t change stack to the one defined it the TSS.</p>
<p>To fix this, you must yourself calculate what the value of <code>esp</code> was <em>before</em> the interrupt. Since you know that the CPU pushes 3 things on the stack when no privilege change happens and you know how much you have pushed on the stack, you can calculate what the value of <code>esp</code> was at the time of the interrupt. This is possible since the CPU won’t change stacks if there is no privilege level change, so the content of <code>esp</code> will be the same as at the time of the interrupt.</p>
<p>To further complicate things, you must think of how to handle case when switching to a new process that should be running in kernel mode. Since you are then using <code>iret</code> without a privilege level change, the CPU won’t update the value of <code>esp</code> with the one placed on the stack, you must update <code>esp</code> yourself.</p>
<h2 id="further-reading-11"><a href="#TOC"><span class="header-section-number">14.4</span> Further Reading</a></h2>
<ul>
<li>For more information about different scheduling algorithms, see <a href="http://wiki.osdev.org/Scheduling_Algorithms"><code class="url">http://wiki.osdev.org/Scheduling_Algorithms</code></a></li>
</ul>
<h1 id="references"><a href="#TOC"><span class="header-section-number">15</span> References</a></h1>
<p>[1] Andrew Tanenbaum, 2007. <em>Modern Operating Systems, 3rd edition</em>. Prentice Hall, Inc.,</p>
<p>[2] OSDev, <em>OSDev</em>, <a href="http://wiki.osdev.org/Main_Page" title="http://wiki.osdev.org/Main_Page">http://wiki.osdev.org/Main_Page</a>,</p>
<p>[3] James Molloy, <em>James M’s kernel development tutorial</em>, <a href="http://www.jamesmolloy.co.uk/tutorial_html/" title="http://www.jamesmolloy.co.uk/tutorial_html/">http://www.jamesmolloy.co.uk/tutorial_html/</a>,</p>
<p>[4] Canonical Ltd, <em>Ubuntu</em>, <a href="http://www.ubuntu.com/" title="http://www.ubuntu.com/">http://www.ubuntu.com/</a>,</p>
<p>[5] Oracle, <em>Oracle VM VirtualBox</em>, <a href="http://www.virtualbox.org/" title="http://www.virtualbox.org/">http://www.virtualbox.org/</a>,</p>
<p>[6] Dennis M. Ritchie Brian W. Kernighan, 1988. <em>The C Programming Language, Second Edition</em>. Prentice Hall, Inc.,</p>
<p>[7] Wikipedia, <em>C (programming language)</em>, <a href="http://en.wikipedia.org/wiki/C_(programming_language)/" title="http://en.wikipedia.org/wiki/C_(programming_language)/">http://en.wikipedia.org/wiki/C_(programming_language)/</a>,</p>
<p>[8] Free Software Foundation, <em>GCC, the GNU Compiler Collection</em>, <a href="http://gcc.gnu.org/" title="http://gcc.gnu.org/">http://gcc.gnu.org/</a>,</p>
<p>[9] NASM, <em>NASM: The Netwide Assembler</em>, <a href="http://www.nasm.us/" title="http://www.nasm.us/">http://www.nasm.us/</a>,</p>
<p>[10] Wikipedia, <em>Shell script</em>, <a href="http://en.wikipedia.org/wiki/Shell_script/" title="http://en.wikipedia.org/wiki/Shell_script/">http://en.wikipedia.org/wiki/Shell_script/</a>,</p>
<p>[11] Free Software Foundation, <em>GNU Make</em>, <a href="http://www.gnu.org/software/make/" title="http://www.gnu.org/software/make/">http://www.gnu.org/software/make/</a>,</p>
<p>[12] Volker Ruppert, <em>bochs: The Open Souce IA-32 emulation project</em>, <a href="http://bochs.sourceforge.net/" title="http://bochs.sourceforge.net/">http://bochs.sourceforge.net/</a>,</p>
<p>[13] QEMU, <em>QEMU</em>, <a href="http://wiki.qemu.org/Main_Page" title="http://wiki.qemu.org/Main_Page">http://wiki.qemu.org/Main_Page</a>,</p>
<p>[14] Wikipedia, <em>BIOS</em>, <a href="https://en.wikipedia.org/wiki/BIOS" title="https://en.wikipedia.org/wiki/BIOS">https://en.wikipedia.org/wiki/BIOS</a>,</p>
<p>[15] Free Software Foundation, <em>GNU GRUB</em>, <a href="http://www.gnu.org/software/grub/" title="http://www.gnu.org/software/grub/">http://www.gnu.org/software/grub/</a>,</p>
<p>[16] Wikipedia, <em>Executable and Linkable Format</em>, <a href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format" title="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format">http://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a>,</p>
<p>[17] Free Software Foundation, <em>Multiboot Specification version 0.6.96</em>, <a href="http://www.gnu.org/software/grub/manual/multiboot/multiboot.html" title="http://www.gnu.org/software/grub/manual/multiboot/multiboot.html">http://www.gnu.org/software/grub/manual/multiboot/multiboot.html</a>,</p>
<p>[18] Lars Nodeen, <em>Bug #426419: configure: error: GRUB requires a working absolute objcopy</em>, <a href="https://bugs.launchpad.net/ubuntu/+source/grub/+bug/426419" title="https://bugs.launchpad.net/ubuntu/+source/grub/+bug/426419">https://bugs.launchpad.net/ubuntu/+source/grub/+bug/426419</a>,</p>
<p>[19] Wikipedia, <em>ISO image</em>, <a href="http://en.wikipedia.org/wiki/ISO_image" title="http://en.wikipedia.org/wiki/ISO_image">http://en.wikipedia.org/wiki/ISO_image</a>,</p>
<p>[20] Bochs, <em>bochsrc</em>, <a href="http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html" title="http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html">http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html</a>,</p>
<p>[21] NASM, <em>RESB and Friends: Declaring Uninitialized Data</em>, <a href="http://www.nasm.us/doc/nasmdoc3.html#section-3.2.2" title="http://www.nasm.us/doc/nasmdoc3.html#section-3.2.2">http://www.nasm.us/doc/nasmdoc3.html#section-3.2.2</a>,</p>
<p>[22] Wikipedia, <em>x86 calling conventions</em>, <a href="http://en.wikipedia.org/wiki/X86_calling_conventions" title="http://en.wikipedia.org/wiki/X86_calling_conventions">http://en.wikipedia.org/wiki/X86_calling_conventions</a>,</p>
<p>[23] Wikipedia, <em>Framebuffer</em>, <a href="http://en.wikipedia.org/wiki/Framebuffer" title="http://en.wikipedia.org/wiki/Framebuffer">http://en.wikipedia.org/wiki/Framebuffer</a>,</p>
<p>[24] Wikipedia, <em>ASCII</em>, <a href="https://en.wikipedia.org/wiki/Ascii" title="https://en.wikipedia.org/wiki/Ascii">https://en.wikipedia.org/wiki/Ascii</a>,</p>
<p>[25] Wikipedia, <em>Serial port</em>, <a href="http://en.wikipedia.org/wiki/Serial_port" title="http://en.wikipedia.org/wiki/Serial_port">http://en.wikipedia.org/wiki/Serial_port</a>,</p>
<p>[26] OSDev, <em>Serial Ports</em>, <a href="http://wiki.osdev.org/Serial_ports" title="http://wiki.osdev.org/Serial_ports">http://wiki.osdev.org/Serial_ports</a>,</p>
<p>[27] WikiBooks, <em>Serial Programming/8250 UART Programming</em>, <a href="http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming" title="http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming">http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming</a>,</p>
<p>[28] Intel, <em>Intel 64 and IA-32 Architectures Software Developer’s Manual Vol. 3A</em>, <a href="http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html/" title="http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html/">http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html/</a>,</p>
<p>[29] NASM, <em>Multi-Line Macros</em>, <a href="http://www.nasm.us/doc/nasmdoc4.html#section-4.3" title="http://www.nasm.us/doc/nasmdoc4.html#section-4.3">http://www.nasm.us/doc/nasmdoc4.html#section-4.3</a>,</p>
<p>[30] SIGOPS, <a href="http://www.acm.uiuc.edu/sigops/roll_your_own/i386/irq.html" title="http://www.acm.uiuc.edu/sigops/roll_your_own/i386/irq.html">http://www.acm.uiuc.edu/sigops/roll_your_own/i386/irq.html</a>,</p>
<p>[31] Andries Brouwer, <em>Keyboard scancodes</em>, <a href="http://www.win.tue.nl/~aeb/linux/kbd/scancodes.html" title="http://www.win.tue.nl/~aeb/linux/kbd/scancodes.html">http://www.win.tue.nl/~aeb/linux/kbd/scancodes.html</a>,</p>
<p>[32] Steve Chamberlain, <em>Using ld, the GNU linker</em>, <a href="http://www.math.utah.edu/docs/info/ld_toc.html" title="http://www.math.utah.edu/docs/info/ld_toc.html">http://www.math.utah.edu/docs/info/ld_toc.html</a>,</p>
<p>[33] OSDev, <em>Programmable Interval Timer</em>, <a href="http://wiki.osdev.org/Programmable_Interval_Timer" title="http://wiki.osdev.org/Programmable_Interval_Timer">http://wiki.osdev.org/Programmable_Interval_Timer</a>,</p>
</div>
</div>

<script type="text/javascript">
    (function() {
        var tables = document.getElementsByTagName("table");
        for (var i = 0; i < tables.length; ++i) {
            var table = tables[i];
            if (table.getElementsByTagName("caption").length > 0) {
                table.className += " has_caption";
            }
        }
     })();
</script>
</body>
</html>
